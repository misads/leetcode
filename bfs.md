# BFS(å¹¿åº¦ä¼˜å…ˆæœç´¢)

## A102. äºŒå‰æ ‘çš„å±‚åºéå†

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™ä½ ä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¯·ä½ è¿”å›å…¶æŒ‰ **å±‚åºéå†** å¾—åˆ°çš„èŠ‚ç‚¹å€¼ã€‚ ï¼ˆå³é€å±‚åœ°ï¼Œä»å·¦åˆ°å³è®¿é—®æ‰€æœ‰èŠ‚ç‚¹ï¼‰ã€‚

**ç¤ºä¾‹ï¼š**
äºŒå‰æ ‘ï¼š`[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›å…¶å±‚æ¬¡éå†ç»“æœï¼š

```
[
  [3],
  [9,20],
  [15,7]
]
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/binary-tree-level-order-traversal/>

#### **æ€è·¯:**

ã€€ã€€[å±‚åºéå†æ¨¡æ¿](/å®ç”¨æ¨¡æ¿?id=å¹¿æœï¼šbfsğŸŒ²å±‚åºéå†)ã€‚  

#### **ä»£ç :**

```python
class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        queue = [root]
        ans = []
        while queue:
            ans.append([q.val for q in queue])
            temp = []
            # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
            for q in queue:
                if q.left:
                    temp.append(q.left)
                if q.right:
                    temp.append(q.right)

            queue = temp
        return ans

```

## A103. äºŒå‰æ ‘çš„é”¯é½¿å½¢å±‚æ¬¡éå†

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„é”¯é½¿å½¢å±‚æ¬¡éå†ã€‚ï¼ˆå³å…ˆä»å·¦å¾€å³ï¼Œå†ä»å³å¾€å·¦è¿›è¡Œä¸‹ä¸€å±‚éå†ï¼Œä»¥æ­¤ç±»æ¨ï¼Œå±‚ä¸å±‚ä¹‹é—´äº¤æ›¿è¿›è¡Œï¼‰ã€‚

ä¾‹å¦‚ï¼š
ç»™å®šäºŒå‰æ ‘ `[3,9,20,null,null,15,7]`,

```
    3
   / \
  9  20
    /  \
   15   7
```

è¿”å›é”¯é½¿å½¢å±‚æ¬¡éå†å¦‚ä¸‹ï¼š

```
[
  [3],
  [20,9],
  [15,7]
]
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal/>

#### **æ€è·¯:**

ã€€ã€€å’Œä¸Šä¸€é¢˜ä¸€æ ·ã€‚ç”¨ä¸€ä¸ª`flag`æ ‡è®°æ˜¯ä»å·¦å¾€å³è¿˜æ˜¯ä»å³å¾€å·¦å°±è¡Œäº†ã€‚  

#### **ä»£ç :**

```python
class Solution:
    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:
        if not root:
            return []

        queue = [root]
        ans = []
        left_to_right = True
        while queue:
            if left_to_right:
                ans.append([q.val for q in queue])
            else:
                ans.append([q.val for q in queue[::-1]])
            left_to_right = not left_to_right
            temp = []
            # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
            for q in queue:
                if q.left:
                    temp.append(q.left)
                if q.right:
                    temp.append(q.right)

            queue = temp
        return ans

```

## A127. å•è¯æ¥é¾™

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™å®šä¸¤ä¸ªå•è¯ï¼ˆ*beginWord* å’Œ *endWord* ï¼‰å’Œä¸€ä¸ªå­—å…¸ï¼Œæ‰¾åˆ°ä» *beginWord* åˆ° *endWord* çš„æœ€çŸ­è½¬æ¢åºåˆ—çš„é•¿åº¦ã€‚è½¬æ¢éœ€éµå¾ªå¦‚ä¸‹è§„åˆ™ï¼š

1. æ¯æ¬¡è½¬æ¢åªèƒ½æ”¹å˜ä¸€ä¸ªå­—æ¯ã€‚
2. è½¬æ¢è¿‡ç¨‹ä¸­çš„ä¸­é—´å•è¯å¿…é¡»æ˜¯å­—å…¸ä¸­çš„å•è¯ã€‚

**è¯´æ˜:**

- å¦‚æœä¸å­˜åœ¨è¿™æ ·çš„è½¬æ¢åºåˆ—ï¼Œè¿”å› 0ã€‚
- æ‰€æœ‰å•è¯å…·æœ‰ç›¸åŒçš„é•¿åº¦ã€‚
- æ‰€æœ‰å•è¯åªç”±å°å†™å­—æ¯ç»„æˆã€‚
- å­—å…¸ä¸­ä¸å­˜åœ¨é‡å¤çš„å•è¯ã€‚
- ä½ å¯ä»¥å‡è®¾ *beginWord* å’Œ *endWord* æ˜¯éç©ºçš„ï¼Œä¸”äºŒè€…ä¸ç›¸åŒã€‚

> **ç¤ºä¾‹ 1:**

```
è¾“å…¥:
beginWord = "hit",
endWord = "cog",
wordList = ["hot","dot","dog","lot","log","cog"]

è¾“å‡º: 5

è§£é‡Š: ä¸€ä¸ªæœ€çŸ­è½¬æ¢åºåˆ—æ˜¯ "hit" -> "hot" -> "dot" -> "dog" -> "cog",
     è¿”å›å®ƒçš„é•¿åº¦ 5ã€‚
```

> **ç¤ºä¾‹ 2:**

```
è¾“å…¥:
beginWord = "hit"
endWord = "cog"
wordList = ["hot","dot","dog","lot","log"]

è¾“å‡º: 0

è§£é‡Š: endWord "cog" ä¸åœ¨å­—å…¸ä¸­ï¼Œæ‰€ä»¥æ— æ³•è¿›è¡Œè½¬æ¢ã€‚
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/word-ladder/)>

#### **æ€è·¯:**

ã€€ã€€æ ‡å‡†çš„bfsã€‚è¿™é¢˜ä¸»è¦çš„æ—¶é—´èŠ±åœ¨**æ‰¾ç›¸é‚»çš„ç»“ç‚¹ä¸Š**ã€‚  

ã€€ã€€å¦‚æœæ¯æ¬¡éƒ½éå†`wordList`å»æ‰¾ç›¸é‚»çš„ç»“ç‚¹ï¼Œè¦èŠ±è´¹å¤§é‡çš„æ—¶é—´(æ—¶é—´å¤æ‚åº¦`O(n^2)`)ã€‚å› æ­¤é‡‡ç”¨æŠŠå•è¯çš„æŸä¸ªå­—æ¯æ›¿æ¢æˆå…¶ä»–å°å†™å­—æ¯çš„æ–¹å¼ï¼Œæ—¶é—´å¤æ‚åº¦ä»…ä¸º`O(n*l)`ï¼Œ`l`ä¸ºå•è¯é•¿åº¦ã€‚  

#### **ä»£ç :**

```python
from collections import defaultdict

class Solution:
    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:
        if endWord not in wordList:
            return 0

        d = defaultdict(list)
        for word in wordList:
            for i in range(len(word)):
                d[word[:i] + "*" + word[i + 1:]].append(word)

        visited = {i: False for i in wordList}
        visited[beginWord] = False

        queue = [beginWord]
        depth = 1
        while queue:
            temp = []
            for q in queue:
                visited[q] = True

            for q in queue:
                if q == endWord:
                    return depth  # åˆ°è¾¾ç»ˆç‚¹

                for i in range(len(q)):
                    key = q[:i] + "*" + q[i + 1:]
                    for neibour in d[key]:
                        if not visited[neibour]:
                            temp.append(neibour)
            depth += 1
            queue = temp
            del temp

        return 0

```

## A310. æœ€å°é«˜åº¦æ ‘

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

å¯¹äºä¸€ä¸ªå…·æœ‰æ ‘ç‰¹å¾çš„æ— å‘å›¾ï¼Œæˆ‘ä»¬å¯é€‰æ‹©ä»»ä½•ä¸€ä¸ªèŠ‚ç‚¹ä½œä¸ºæ ¹ã€‚å›¾å› æ­¤å¯ä»¥æˆä¸ºæ ‘ï¼Œåœ¨æ‰€æœ‰å¯èƒ½çš„æ ‘ä¸­ï¼Œå…·æœ‰æœ€å°é«˜åº¦çš„æ ‘è¢«ç§°ä¸ºæœ€å°é«˜åº¦æ ‘ã€‚ç»™å‡ºè¿™æ ·çš„ä¸€ä¸ªå›¾ï¼Œå†™å‡ºä¸€ä¸ªå‡½æ•°æ‰¾åˆ°æ‰€æœ‰çš„æœ€å°é«˜åº¦æ ‘å¹¶è¿”å›ä»–ä»¬çš„æ ¹èŠ‚ç‚¹ã€‚

**æ ¼å¼**

è¯¥å›¾åŒ…å« `n` ä¸ªèŠ‚ç‚¹ï¼Œæ ‡è®°ä¸º `0` åˆ° `n - 1`ã€‚ç»™å®šæ•°å­— `n` å’Œä¸€ä¸ªæ— å‘è¾¹ `edges` åˆ—è¡¨ï¼ˆæ¯ä¸€ä¸ªè¾¹éƒ½æ˜¯ä¸€å¯¹æ ‡ç­¾ï¼‰ã€‚

ä½ å¯ä»¥å‡è®¾æ²¡æœ‰é‡å¤çš„è¾¹ä¼šå‡ºç°åœ¨ `edges` ä¸­ã€‚ç”±äºæ‰€æœ‰çš„è¾¹éƒ½æ˜¯æ— å‘è¾¹ï¼Œ `[0, 1]`å’Œ `[1, 0]` æ˜¯ç›¸åŒçš„ï¼Œå› æ­¤ä¸ä¼šåŒæ—¶å‡ºç°åœ¨ `edges` é‡Œã€‚

> **ç¤ºä¾‹ 1:**

```
è¾“å…¥: n = 4, edges = [[1, 0], [1, 2], [1, 3]]

        0
        |
        1
       / \
      2   3 

è¾“å‡º: [1]
```

> **ç¤ºä¾‹ 2:**

```
è¾“å…¥: n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]

     0  1  2
      \ | /
        3
        |
        4
        |
        5 

è¾“å‡º: [3, 4]
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/minimum-height-trees/>

#### **æ€è·¯:**

ã€€ã€€æ„å»ºå›¾ï¼Œå¾ªç¯éå†å›¾ï¼Œæ‰¾å‡ºå¶å­èŠ‚ç‚¹ã€‚å»é™¤å¶å­èŠ‚ç‚¹ã€‚ç›´åˆ°å›¾ä¸­èŠ‚ç‚¹åªå‰©ä¸‹2ä¸ªæˆ–1ä¸ªã€‚è¿”å›å‰©ä¸‹çš„èŠ‚ç‚¹ã€‚  

#### **ä»£ç :**

```python
from collections import defaultdict

class Solution:
    def findMinHeightTrees(self, n: int, edges: List[List[int]]) -> List[int]:
        if not n:
            return []
        if not edges:
            return list(range(n))

        graph = defaultdict(list)
        for x, y in edges:
            graph[x].append(y)
            graph[y].append(x)

        nodes = set(range(n))
        while True:
            if len(nodes) <= 2:
                return [n for n in nodes]
                
            leaves = []
            for k in graph:
                if len(graph[k]) == 1:
                    leaves.append(k)
                    nodes.remove(k)

            for k in leaves:
                    o = graph[k][0]
                    graph[k].clear()
                    graph[o].remove(k)

```

## A417. å¤ªå¹³æ´‹å¤§è¥¿æ´‹æ°´æµé—®é¢˜

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ª `m x n` çš„éè´Ÿæ•´æ•°çŸ©é˜µæ¥è¡¨ç¤ºä¸€ç‰‡å¤§é™†ä¸Šå„ä¸ªå•å…ƒæ ¼çš„é«˜åº¦ã€‚â€œå¤ªå¹³æ´‹â€å¤„äºå¤§é™†çš„å·¦è¾¹ç•Œå’Œä¸Šè¾¹ç•Œï¼Œè€Œâ€œå¤§è¥¿æ´‹â€å¤„äºå¤§é™†çš„å³è¾¹ç•Œå’Œä¸‹è¾¹ç•Œã€‚

è§„å®šæ°´æµåªèƒ½æŒ‰ç…§ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘æµåŠ¨ï¼Œä¸”åªèƒ½ä»é«˜åˆ°ä½æˆ–è€…åœ¨åŒç­‰é«˜åº¦ä¸ŠæµåŠ¨ã€‚

è¯·æ‰¾å‡ºé‚£äº›æ°´æµæ—¢å¯ä»¥æµåŠ¨åˆ°â€œå¤ªå¹³æ´‹â€ï¼Œåˆèƒ½æµåŠ¨åˆ°â€œå¤§è¥¿æ´‹â€çš„é™†åœ°å•å…ƒçš„åæ ‡ã€‚ 

**æç¤ºï¼š**

1. è¾“å‡ºåæ ‡çš„é¡ºåºä¸é‡è¦
2. *m* å’Œ *n* éƒ½å°äº150

> **ç¤ºä¾‹ï¼š** 

```
ç»™å®šä¸‹é¢çš„ 5x5 çŸ©é˜µ:

  å¤ªå¹³æ´‹ ~   ~   ~   ~   ~ 
       ~  1   2   2   3  (5) *
       ~  3   2   3  (4) (4) *
       ~  2   4  (5)  3   1  *
       ~ (6) (7)  1   4   5  *
       ~ (5)  1   1   2   4  *
          *   *   *   *   * å¤§è¥¿æ´‹

è¿”å›:

[[0, 4], [1, 3], [1, 4], [2, 2], [3, 0], [3, 1], [4, 0]] (ä¸Šå›¾ä¸­å¸¦æ‹¬å·çš„å•å…ƒ).
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/pacific-atlantic-water-flow/>

#### **æ€è·¯:**

ã€€ã€€ç±»ä¼¼æ³›æ´ªçš„æ€æƒ³ï¼Œä»å¤ªå¹³æ´‹å’Œå¤§è¥¿æ´‹é€†æµå¾€ä¸Šï¼Œåˆ†åˆ«bfsï¼Œè®°å½•æ‰€æœ‰èƒ½åˆ°è¾¾çš„ç‚¹ï¼Œç„¶åå–äº¤é›†ã€‚  

#### **ä»£ç :**

```python
class Solution:
    def pacificAtlantic(self, matrix: List[List[int]]) -> List[List[int]]:
        m = len(matrix)
        if not m:
            return []
        n = len(matrix[0])

        pacific = []
        atlantic = []
        for i in range(m):
            for j in range(n):
                if i == 0 or j == 0:
                    pacific.append((i, j))
                if i == m - 1 or j == n - 1:
                    atlantic.append((i, j))

        arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]

        def bfs(queue):
            can_reach = set()
            visited = [[False for _ in range(n)] for _ in range(m)]
            while queue:
                for i, j in queue:
                    visited[i][j] = True
                    can_reach.add((i, j))

                temp = []
                for i, j in queue:
                    for di, dj in arounds:
                        x, y = i + di, j + dj
                        if x < 0 or y < 0 or x >= m or y >= n:
                            continue
                        if not visited[x][y] and matrix[x][y] >= matrix[i][j]:
                            temp.append((x, y))

                queue = temp
            return can_reach

        a = bfs(pacific)
        b = bfs(atlantic)
        c = a & b
        return [_ for _ in c]
```


## A429. Nå‰æ ‘çš„å±‚åºéå†

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ª N å‰æ ‘ï¼Œè¿”å›å…¶èŠ‚ç‚¹å€¼çš„*å±‚åºéå†*ã€‚ (å³ä»å·¦åˆ°å³ï¼Œé€å±‚éå†)ã€‚

ä¾‹å¦‚ï¼Œç»™å®šä¸€ä¸ª `3å‰æ ‘` :

<img src="_img/429.png" style="zoom:40%"/>

 

è¿”å›å…¶å±‚åºéå†:

```
[
     [1],
     [3,2,4],
     [5,6]
]
```

**è¯´æ˜:**

1. æ ‘çš„æ·±åº¦ä¸ä¼šè¶…è¿‡ `1000`ã€‚
2. æ ‘çš„èŠ‚ç‚¹æ€»æ•°ä¸ä¼šè¶…è¿‡ `5000`ã€‚

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/n-ary-tree-level-order-traversal/>

#### **æ€è·¯:**

ã€€ã€€[å±‚åºéå†æ¨¡æ¿](/å®ç”¨æ¨¡æ¿?id=å¹¿æœï¼šbfsğŸŒ²å±‚åºéå†)ã€‚  

#### **ä»£ç :**

```python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""

class Solution:
    def levelOrder(self, root: 'Node') -> List[List[int]]:
        if not root:
            return 

        queue = [root]
        ans = []
        while queue:
            temp = []
            ans.append([q.val for q in queue])
            # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
            for q in queue:
                for children in q.children:
                    temp.append(children)

            queue = temp
        return ans
      
```

## A513. æ‰¾æ ‘å·¦ä¸‹è§’çš„å€¼

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªäºŒå‰æ ‘ï¼Œåœ¨æ ‘çš„æœ€åä¸€è¡Œæ‰¾åˆ°æœ€å·¦è¾¹çš„å€¼ã€‚

> **ç¤ºä¾‹ 1:**

```
è¾“å…¥:

    2
   / \
  1   3

è¾“å‡º:
1 
```

> **ç¤ºä¾‹ 2:**

```
è¾“å…¥:

        1
       / \
      2   3
     /   / \
    4   5   6
       /
      7

è¾“å‡º:
7
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/find-bottom-left-tree-value/>

#### **æ€è·¯:**

ã€€ã€€[å±‚åºéå†æ¨¡æ¿](/å®ç”¨æ¨¡æ¿?id=å¹¿æœï¼šbfsğŸŒ²å±‚åºéå†)ã€‚ 

#### **ä»£ç :**

```python
class Solution:
    def findBottomLeftValue(self, root: TreeNode) -> int:
        if not root:
            return 

        queue = [root]
        ans = 0
        while queue:
            temp = []
            # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
            for q in queue:
                if q.left:
                    temp.append(q.left)
                if q.right:
                    temp.append(q.right)
            if not temp:
                ans = queue[0].val

            queue = temp
        return ans
```

## A515. åœ¨æ¯ä¸ªæ ‘è¡Œä¸­æ‰¾æœ€å¤§å€¼

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

æ‚¨éœ€è¦åœ¨äºŒå‰æ ‘çš„æ¯ä¸€è¡Œä¸­æ‰¾åˆ°æœ€å¤§çš„å€¼ã€‚

> **ç¤ºä¾‹ï¼š**

```
è¾“å…¥: 

          1
         / \
        3   2
       / \   \  
      5   3   9 

è¾“å‡º: [1, 3, 9]
```

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row/>

#### **æ€è·¯:**

ã€€ã€€[å±‚åºéå†æ¨¡æ¿](/å®ç”¨æ¨¡æ¿?id=å¹¿æœï¼šbfsğŸŒ²å±‚åºéå†)ã€‚ 

#### **ä»£ç :**

```python

class Solution:
    def largestValues(self, root: TreeNode) -> List[int]:
        if not root:
            return 

        queue = [root]
        ans = []
        while queue:
            temp = []
            ans.append(max([node.val for node in queue]))
            # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
            for q in queue:
                if q.left:
                    temp.append(q.left)
                if q.right:
                    temp.append(q.right)

            queue = temp
        return ans
```



## A529. æ‰«é›·æ¸¸æˆ

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

è®©æˆ‘ä»¬ä¸€èµ·æ¥ç©æ‰«é›·æ¸¸æˆï¼

ç»™å®šä¸€ä¸ªä»£è¡¨æ¸¸æˆæ¿çš„äºŒç»´å­—ç¬¦çŸ©é˜µã€‚ **'M'** ä»£è¡¨ä¸€ä¸ª**æœªæŒ–å‡ºçš„**åœ°é›·ï¼Œ**'E'** ä»£è¡¨ä¸€ä¸ª**æœªæŒ–å‡ºçš„**ç©ºæ–¹å—ï¼Œ**'B'** ä»£è¡¨æ²¡æœ‰ç›¸é‚»ï¼ˆä¸Šï¼Œä¸‹ï¼Œå·¦ï¼Œå³ï¼Œå’Œæ‰€æœ‰4ä¸ªå¯¹è§’çº¿ï¼‰åœ°é›·çš„**å·²æŒ–å‡ºçš„**ç©ºç™½æ–¹å—ï¼Œ**æ•°å­—**ï¼ˆ'1' åˆ° '8'ï¼‰è¡¨ç¤ºæœ‰å¤šå°‘åœ°é›·ä¸è¿™å—**å·²æŒ–å‡ºçš„**æ–¹å—ç›¸é‚»ï¼Œ**'X'** åˆ™è¡¨ç¤ºä¸€ä¸ª**å·²æŒ–å‡ºçš„**åœ°é›·ã€‚

ç°åœ¨ç»™å‡ºåœ¨æ‰€æœ‰**æœªæŒ–å‡ºçš„**æ–¹å—ä¸­ï¼ˆ'M'æˆ–è€…'E'ï¼‰çš„ä¸‹ä¸€ä¸ªç‚¹å‡»ä½ç½®ï¼ˆè¡Œå’Œåˆ—ç´¢å¼•ï¼‰ï¼Œæ ¹æ®ä»¥ä¸‹è§„åˆ™ï¼Œè¿”å›ç›¸åº”ä½ç½®è¢«ç‚¹å‡»åå¯¹åº”çš„é¢æ¿ï¼š

1. å¦‚æœä¸€ä¸ªåœ°é›·ï¼ˆ'M'ï¼‰è¢«æŒ–å‡ºï¼Œæ¸¸æˆå°±ç»“æŸäº†- æŠŠå®ƒæ”¹ä¸º **'X'**ã€‚
2. å¦‚æœä¸€ä¸ª**æ²¡æœ‰ç›¸é‚»åœ°é›·**çš„ç©ºæ–¹å—ï¼ˆ'E'ï¼‰è¢«æŒ–å‡ºï¼Œä¿®æ”¹å®ƒä¸ºï¼ˆ'B'ï¼‰ï¼Œå¹¶ä¸”æ‰€æœ‰å’Œå…¶ç›¸é‚»çš„æ–¹å—éƒ½åº”è¯¥è¢«é€’å½’åœ°æ­éœ²ã€‚
3. å¦‚æœä¸€ä¸ª**è‡³å°‘ä¸ä¸€ä¸ªåœ°é›·ç›¸é‚»**çš„ç©ºæ–¹å—ï¼ˆ'E'ï¼‰è¢«æŒ–å‡ºï¼Œä¿®æ”¹å®ƒä¸ºæ•°å­—ï¼ˆ'1'åˆ°'8'ï¼‰ï¼Œè¡¨ç¤ºç›¸é‚»åœ°é›·çš„æ•°é‡ã€‚
4. å¦‚æœåœ¨æ­¤æ¬¡ç‚¹å‡»ä¸­ï¼Œè‹¥æ— æ›´å¤šæ–¹å—å¯è¢«æ­éœ²ï¼Œåˆ™è¿”å›é¢æ¿ã€‚

> **ç¤ºä¾‹ 1ï¼š**

```
è¾“å…¥: 

[['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'M', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E'],
 ['E', 'E', 'E', 'E', 'E']]

Click : [3,0]

è¾“å‡º: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

è§£é‡Š:
```

<img src="_img/529_1.png" style="zoom:40%"/>  

> **ç¤ºä¾‹ 2ï¼š**

```
è¾“å…¥: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'M', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

Click : [1,2]

è¾“å‡º: 

[['B', '1', 'E', '1', 'B'],
 ['B', '1', 'X', '1', 'B'],
 ['B', '1', '1', '1', 'B'],
 ['B', 'B', 'B', 'B', 'B']]

è§£é‡Š:
```

<img src="_img/529_2.png" style="zoom:40%"/>

**æ³¨æ„ï¼š**

1. è¾“å…¥çŸ©é˜µçš„å®½å’Œé«˜çš„èŒƒå›´ä¸º [1,50]ã€‚
2. ç‚¹å‡»çš„ä½ç½®åªèƒ½æ˜¯æœªè¢«æŒ–å‡ºçš„æ–¹å— ('M' æˆ–è€… 'E')ï¼Œè¿™ä¹Ÿæ„å‘³ç€é¢æ¿è‡³å°‘åŒ…å«ä¸€ä¸ªå¯ç‚¹å‡»çš„æ–¹å—ã€‚
3. è¾“å…¥é¢æ¿ä¸ä¼šæ˜¯æ¸¸æˆç»“æŸçš„çŠ¶æ€ï¼ˆå³æœ‰åœ°é›·å·²è¢«æŒ–å‡ºï¼‰ã€‚
4. ç®€å•èµ·è§ï¼ŒæœªæåŠçš„è§„åˆ™åœ¨è¿™ä¸ªé—®é¢˜ä¸­å¯è¢«å¿½ç•¥ã€‚ä¾‹å¦‚ï¼Œå½“æ¸¸æˆç»“æŸæ—¶ä½ ä¸éœ€è¦æŒ–å‡ºæ‰€æœ‰åœ°é›·ï¼Œè€ƒè™‘æ‰€æœ‰ä½ å¯èƒ½èµ¢å¾—æ¸¸æˆæˆ–æ ‡è®°æ–¹å—çš„æƒ…å†µã€‚

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/minesweeper/>

#### **æ€è·¯:**

ã€€ã€€æœ¬é¢˜çš„éš¾ç‚¹åœ¨äºç†è§£é¢˜æ„ã€‚æ ¹æ®ç‚¹å‡»çš„ä½ç½®ä¸åŒå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸‰ç§æƒ…å†µï¼š    

- ç‚¹å‡»çš„ä½ç½®æ˜¯åœ°é›·ï¼Œå°†è¯¥ä½ç½®ä¿®æ”¹ä¸º`"X"`ï¼Œç›´æ¥è¿”å›ã€‚  
- ç‚¹å‡»ä½ç½®çš„`ä¹å®«æ ¼å†…æœ‰åœ°é›·`ï¼Œå°†è¯¥ä½ç½®ä¿®æ”¹ä¸ºä¹å®«æ ¼å†…åœ°é›·çš„æ•°é‡ï¼Œç„¶åç›´æ¥è¿”å›ã€‚
- ç‚¹å‡»ä½ç½®çš„`ä¹å®«æ ¼å†…æ²¡æœ‰åœ°é›·`ï¼Œè¿›è¡Œdfsæˆ–bfså‘å‘¨å›´æ‰©å±•ï¼Œç›´åˆ°æ‰€æœ‰è¾¹ç•Œçš„ä¹å®«æ ¼å†…éƒ½æœ‰åœ°é›·ã€‚  

#### **ä»£ç :**

```python
class Solution:
    def updateBoard(self, board: List[List[str]], click: List[int]) -> List[List[str]]:
        x, y = click
        if board[x][y] == 'M':  # è¸©åœ°é›·äº†
            board[x][y] = 'X'
            return board

        m = len(board)
        n = len(board[0])
        counts = [[0 for _ in range(n)] for _ in range(m)]
        visited = [[False for _ in range(n)] for _ in range(m)]
        arounds = [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]  # 8ä¸ªæ–¹å‘

        def get_around(i, j):  # è·å–å‘¨å›´ä¹å®«æ ¼
            count = 0
            for x in range(max(0, i-1), min(m, i+2)):
                for y in range(max(0, j-1), min(n, j+2)):
                    if (x != i or y != j) and board[x][y] == 'M':
                        count += 1
            return count

        for i in range(m):
            for j in range(n):
                counts[i][j] = get_around(i, j)  # æ¯ä¸ªä½ç½®çš„æ•°å­—

        if counts[x][y]:  # å¦‚æœç‚¹çš„ä½ç½®æ˜¯æœ‰æ•°å­—çš„
            board[x][y] = str(counts[x][y])
            return board

        queue = [(x, y)]  # bfs
        while queue:
            for i, j in queue:
                visited[i][j] = True
                if board[i][j] != 'M':  # åœ°é›·ä¸èƒ½ä¿®æ”¹
                    board[i][j] = str(counts[i][j]) if counts[i][j] else 'B'

            temp = []
            for i, j in queue:
                if counts[i][j]:  # ä¸æ˜¯0çš„ä½ç½®ä¸ç»§ç»­
                    continue
                for di, dj in arounds:
                    ni, nj = i + di, j + dj  # ä¸‹ä¸€ä¸ªä½ç½®
                    if ni < 0 or nj < 0 or ni >= m or nj >= n:  # è¾¹ç•Œ
                        continue
                    if not visited[ni][nj] and (ni, nj) not in temp:
                        temp.append((ni, nj))

            queue = temp
        return board
      
```

## A542. 01 çŸ©é˜µ

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªç”± 0 å’Œ 1 ç»„æˆçš„çŸ©é˜µï¼Œæ‰¾å‡ºæ¯ä¸ªå…ƒç´ åˆ°æœ€è¿‘çš„ 0 çš„è·ç¦»ã€‚

ä¸¤ä¸ªç›¸é‚»å…ƒç´ é—´çš„è·ç¦»ä¸º 1 ã€‚

> **ç¤ºä¾‹ 1:**  

è¾“å…¥:

```
0 0 0
0 1 0
0 0 0
```

è¾“å‡º:

```
0 0 0
0 1 0
0 0 0
```

> **ç¤ºä¾‹ 2:** 

è¾“å…¥:

```
0 0 0
0 1 0
1 1 1
```

è¾“å‡º:

```
0 0 0
0 1 0
1 2 1
```

#### é¢˜ç›®é“¾æ¥



#### **æ€è·¯:**

ã€€ã€€**æ–¹æ³•ä¸€ï¼š**bfsã€‚å°†æ‰€æœ‰çš„`"0"`çœ‹åšä¸€ä¸ªæ•´ä½“ï¼Œå‘å…¶ä»–æ•°å­—çš„ä½ç½®è…èš€(å°†å®ƒä»¬å˜æˆ0)ï¼Œå½“æ ¼å­ä¸Šæ‰€æœ‰æ•°å­—éƒ½ä¸º`"0"`æ—¶ç»“æŸå¾ªç¯ã€‚è®°å½•å¾ªç¯çš„æ·±åº¦å°±æ˜¯ç»“æœã€‚  

ã€€ã€€**æ–¹æ³•äºŒï¼š**åŠ¨æ€è§„åˆ’ï¼Œå› ä¸ºæœ€è¿‘çš„`"0"`è¦ä¹ˆåœ¨å·¦ä¸Šæ–¹ï¼Œè¦ä¹ˆåœ¨å³ä¸‹æ–¹ã€‚å› æ­¤åªè¦åˆ†**åˆ«ä»å·¦ä¸Šè§’åˆ°å³ä¸‹è§’**å’Œ**ä»å³ä¸‹è§’åˆ°å·¦ä¸Šè§’**åŠ¨æ€è§„åˆ’ä¸€æ¬¡ï¼Œå°±å¾—åˆ°äº†æœ€ç»ˆçš„ç»“æœã€‚  

ã€€ã€€å…¶ä¸­ä»å·¦ä¸Šåˆ°å³ä¸‹çš„çŠ¶æ€è½¬ç§»æ–¹ç¨‹ä¸º`dp[i][j] = min(dp[i][j], dp[i-1][j] + 1, dp[i][j-1] + 1)`ã€‚  ã€€ã€€

#### **ä»£ç :**

ã€€ã€€**æ–¹æ³•ä¸€ï¼š**(bfs)

```python
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
        grid = matrix
        m = len(matrix)
        if not m: return []
        n = len(matrix[0])

        ans = [[0 for _ in range(n)] for _ in range(m)]
        temp = []

        def rot(x, y):
            if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):
                return False
            if grid[x][y] != 0:  # æˆåŠŸè…çƒ‚æ–°é²œçš„æ©˜å­ï¼Œè¿”å›True
                grid[x][y] = 0  
                temp.append((x, y))
                return True
            return False

        depth = 0
        queue = []
        for i in range(m):
            for j in range(n):
                if grid[i][j] == 0:  # è…çƒ‚çš„æ©˜å­
                    queue.append((i, j))

        while queue: 
            temp = []
            for i, j in queue:
                ans[i][j] = depth
                for di, dj in arounds:
                    rot(i + di, j + dj)

            depth += 1

            queue = temp

        return ans
```

ã€€ã€€**æ–¹æ³•äºŒï¼š**(dp)

```python
class Solution:
    def updateMatrix(self, matrix: List[List[int]]) -> List[List[int]]:
        arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
        grid = matrix
        m = len(matrix)
        if not m: return []
        n = len(matrix[0])

        dp = [[float('inf') for _ in range(n)] for _ in range(m)]
        
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == 0:
                    dp[i][j] = 0

        for i in range(m):  # å·¦ä¸Šåˆ°å³ä¸‹
            for j in range(n):
                if i > 0:
                    dp[i][j] = min(dp[i][j], dp[i-1][j] + 1)
                if j > 0:
                    dp[i][j] = min(dp[i][j], dp[i][j-1] + 1)

        for i in range(m-1,-1,-1):  # å³ä¸‹åˆ°å·¦ä¸Š
            for j in range(n-1,-1,-1):
                if i < m-1:
                    dp[i][j] = min(dp[i][j], dp[i+1][j] + 1)
                if j < n-1:
                    dp[i][j] = min(dp[i][j], dp[i][j+1] + 1)
                    
        return dp
      
```

## A675. ä¸ºé«˜å°”å¤«æ¯”èµ›ç æ ‘

éš¾åº¦`å›°éš¾`

#### é¢˜ç›®æè¿°

ä½ è¢«è¯·æ¥ç»™ä¸€ä¸ªè¦ä¸¾åŠé«˜å°”å¤«æ¯”èµ›çš„æ ‘æ—ç æ ‘. æ ‘æ—ç”±ä¸€ä¸ªéè´Ÿçš„äºŒç»´æ•°ç»„è¡¨ç¤ºï¼Œ åœ¨è¿™ä¸ªæ•°ç»„ä¸­ï¼š

1. `0` è¡¨ç¤ºéšœç¢ï¼Œæ— æ³•è§¦ç¢°åˆ°.
2. `1` è¡¨ç¤ºå¯ä»¥è¡Œèµ°çš„åœ°é¢.
3. `æ¯” 1 å¤§çš„æ•°` è¡¨ç¤ºä¸€é¢—å…è®¸èµ°è¿‡çš„æ ‘çš„é«˜åº¦.

æ¯ä¸€æ­¥ï¼Œä½ éƒ½å¯ä»¥å‘ä¸Šã€ä¸‹ã€å·¦ã€å³å››ä¸ªæ–¹å‘ä¹‹ä¸€ç§»åŠ¨ä¸€ä¸ªå•ä½ï¼Œå¦‚æœä½ ç«™çš„åœ°æ–¹æœ‰ä¸€æ£µæ ‘ï¼Œé‚£ä¹ˆä½ å¯ä»¥å†³å®šæ˜¯å¦è¦ç å€’å®ƒã€‚

ä½ è¢«è¦æ±‚æŒ‰ç…§æ ‘çš„é«˜åº¦ä»ä½å‘é«˜ç æ‰æ‰€æœ‰çš„æ ‘ï¼Œæ¯ç è¿‡ä¸€é¢—æ ‘ï¼Œæ ‘çš„é«˜åº¦å˜ä¸º 1 ã€‚

ä½ å°†ä»ï¼ˆ0ï¼Œ0ï¼‰ç‚¹å¼€å§‹å·¥ä½œï¼Œä½ åº”è¯¥è¿”å›ä½ ç å®Œæ‰€æœ‰æ ‘éœ€è¦èµ°çš„æœ€å°æ­¥æ•°ã€‚ å¦‚æœä½ æ— æ³•ç å®Œæ‰€æœ‰çš„æ ‘ï¼Œè¿”å› -1 ã€‚

å¯ä»¥ä¿è¯çš„æ˜¯ï¼Œæ²¡æœ‰ä¸¤æ£µæ ‘çš„é«˜åº¦æ˜¯ç›¸åŒçš„ï¼Œå¹¶ä¸”ä½ è‡³å°‘éœ€è¦ç å€’ä¸€æ£µæ ‘ã€‚

> **ç¤ºä¾‹ 1:**

```
è¾“å…¥: 
[
 [1,2,3],
 [0,0,4],
 [7,6,5]
]
è¾“å‡º: 6
```

> **ç¤ºä¾‹ 2:**

```
è¾“å…¥: 
[
 [1,2,3],
 [0,0,0],
 [7,6,5]
]
è¾“å‡º: -1
```

> **ç¤ºä¾‹ 3:**

```
è¾“å…¥: 
[
 [2,3,4],
 [0,0,5],
 [8,7,6]
]
è¾“å‡º: 6
è§£é‡Š: (0,0) ä½ç½®çš„æ ‘ï¼Œä½ å¯ä»¥ç›´æ¥ç å»ï¼Œä¸ç”¨ç®—æ­¥æ•°
```

**æç¤ºï¼š**

- `1 <= forest.length <= 50`
- `1 <= forest[i].length <= 50`
- `0 <= forest[i][j] <= 10^9`

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/cut-off-trees-for-golf-event/>

#### **æ€è·¯:**

ã€€ã€€`"0"`çš„ä½ç½®æ˜¯éšœç¢ç‰©ï¼Œå…¶ä»–çš„ä½ç½®(**åŒ…æ‹¬æœ‰æ ‘çš„ä½ç½®**)éƒ½æ˜¯å¯ä»¥èµ°çš„ã€‚  

ã€€ã€€å…ˆä»å‡ºå‘ç‚¹`(0, 0)`å¼€å§‹ï¼Œæ‰¾ä¸æœ€çŸ®çš„ä¸€æ£µæ ‘ä¹‹é—´çš„æœ€çŸ­è·¯å¾„(ç”¨bfs)ï¼Œç„¶åç å€’è¿™æ£µæ ‘ï¼Œå†æ‰¾åˆ°å‰©ä¸‹æ ‘ä¸­æœ€çŸ®çš„ä¸€æ£µçš„æœ€çŸ­è·¯å¾„ã€‚æœ€åæ‰€æœ‰çš„è·¯å¾„å’Œå°±æ˜¯ç»“æœã€‚  

ã€€ã€€å¦‚æœæœ‰æ ‘è¢«éšœç¢ç‰©æŒ¡ä½ï¼Œè¿”å›`-1`ã€‚  

#### **ä»£ç :**

```python
class Solution:
    def cutOffTree(self, forest: List[List[int]]) -> int:
        arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
        m = len(forest)
        if not m: return 0
        n = len(forest[0])

        dp = [[float('inf') for _ in range(n)] for _ in range(m)]
        dp[0][0] = 0
        sorted_trees = []
        for i in range(m):
             for j in range(n):
                if forest[i][j] > 1:
                     sorted_trees.append((forest[i][j], i, j))

        sorted_trees.sort()

        def from_to(start, end_x, end_y):  # bfsæœ€çŸ­è·¯å¾„æ¨¡æ¿
            visited = {start}
            queue = [start]

            count = 0
            while queue:
                for i, j in queue:
                    if i == end_x and j == end_y:
                        return count
                      
                count += 1

                temp = []
                for i, j in queue:
                    for di, dj in arounds:
                        x, y = i + di, j + dj
                        if x < 0 or y < 0 or x >= m or y >= n or forest[x][y] == 0:  # è¾¹ç•Œæˆ–éšœç¢
                            continue
                        if (x,y) not in visited: 
                            visited.add((x,y))
                            temp.append((x, y))

                queue = temp

            return -1

        ans = 0
        cur = (0, 0)
        for _, x, y in sorted_trees:
            next_tree = from_to(cur, x, y)
            if next_tree == -1:
                return -1
            ans += next_tree
            cur = (x, y)

        return ans

```

## A690. å‘˜å·¥çš„é‡è¦æ€§

éš¾åº¦`ç®€å•`

#### é¢˜ç›®æè¿°

ç»™å®šä¸€ä¸ªä¿å­˜å‘˜å·¥ä¿¡æ¯çš„æ•°æ®ç»“æ„ï¼Œå®ƒåŒ…å«äº†å‘˜å·¥**å”¯ä¸€çš„id**ï¼Œ**é‡è¦åº¦** å’Œ **ç›´ç³»ä¸‹å±çš„id**ã€‚

æ¯”å¦‚ï¼Œå‘˜å·¥1æ˜¯å‘˜å·¥2çš„é¢†å¯¼ï¼Œå‘˜å·¥2æ˜¯å‘˜å·¥3çš„é¢†å¯¼ã€‚ä»–ä»¬ç›¸åº”çš„é‡è¦åº¦ä¸º15, 10, 5ã€‚é‚£ä¹ˆå‘˜å·¥1çš„æ•°æ®ç»“æ„æ˜¯[1, 15, [2]]ï¼Œå‘˜å·¥2çš„æ•°æ®ç»“æ„æ˜¯[2, 10, [3]]ï¼Œå‘˜å·¥3çš„æ•°æ®ç»“æ„æ˜¯[3, 5, []]ã€‚æ³¨æ„è™½ç„¶å‘˜å·¥3ä¹Ÿæ˜¯å‘˜å·¥1çš„ä¸€ä¸ªä¸‹å±ï¼Œä½†æ˜¯ç”±äº**å¹¶ä¸æ˜¯ç›´ç³»**ä¸‹å±ï¼Œå› æ­¤æ²¡æœ‰ä½“ç°åœ¨å‘˜å·¥1çš„æ•°æ®ç»“æ„ä¸­ã€‚

ç°åœ¨è¾“å…¥ä¸€ä¸ªå…¬å¸çš„æ‰€æœ‰å‘˜å·¥ä¿¡æ¯ï¼Œä»¥åŠå•ä¸ªå‘˜å·¥idï¼Œè¿”å›è¿™ä¸ªå‘˜å·¥å’Œä»–æ‰€æœ‰ä¸‹å±çš„é‡è¦åº¦ä¹‹å’Œã€‚

> **ç¤ºä¾‹ 1:**

```
è¾“å…¥: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1
è¾“å‡º: 11
è§£é‡Š:
å‘˜å·¥1è‡ªèº«çš„é‡è¦åº¦æ˜¯5ï¼Œä»–æœ‰ä¸¤ä¸ªç›´ç³»ä¸‹å±2å’Œ3ï¼Œè€Œä¸”2å’Œ3çš„é‡è¦åº¦å‡ä¸º3ã€‚å› æ­¤å‘˜å·¥1çš„æ€»é‡è¦åº¦æ˜¯ 5 + 3 + 3 = 11ã€‚
```

**æ³¨æ„:**

1. ä¸€ä¸ªå‘˜å·¥æœ€å¤šæœ‰ä¸€ä¸ª**ç›´ç³»**é¢†å¯¼ï¼Œä½†æ˜¯å¯ä»¥æœ‰å¤šä¸ª**ç›´ç³»**ä¸‹å±
2. å‘˜å·¥æ•°é‡ä¸è¶…è¿‡2000ã€‚

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/employee-importance/>

#### **æ€è·¯:**

ã€€ã€€é€’å½’ã€‚  

#### **ä»£ç :**

```python
from collections import defaultdict

class Solution:
    def getImportance(self, employees: List['Employee'], id: int) -> int:
        subs = defaultdict(list)
        importance = defaultdict(int)
        for e in employees:
            subs[e.id] = e.subordinates
            importance[e.id] = e.importance
            
        def dfs(node):
            me = importance[node]
            for sub in subs[node]:
                me += dfs(sub)
            return me

        return dfs(id)
      
```

## A743. ç½‘ç»œå»¶è¿Ÿæ—¶é—´

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

æœ‰ `N` ä¸ªç½‘ç»œèŠ‚ç‚¹ï¼Œæ ‡è®°ä¸º `1` åˆ° `N`ã€‚

ç»™å®šä¸€ä¸ªåˆ—è¡¨ `times`ï¼Œè¡¨ç¤ºä¿¡å·ç»è¿‡**æœ‰å‘**è¾¹çš„ä¼ é€’æ—¶é—´ã€‚ `times[i] = (u, v, w)`ï¼Œå…¶ä¸­ `u` æ˜¯æºèŠ‚ç‚¹ï¼Œ`v` æ˜¯ç›®æ ‡èŠ‚ç‚¹ï¼Œ `w` æ˜¯ä¸€ä¸ªä¿¡å·ä»æºèŠ‚ç‚¹ä¼ é€’åˆ°ç›®æ ‡èŠ‚ç‚¹çš„æ—¶é—´ã€‚

ç°åœ¨ï¼Œæˆ‘ä»¬ä»æŸä¸ªèŠ‚ç‚¹ `K` å‘å‡ºä¸€ä¸ªä¿¡å·ã€‚éœ€è¦å¤šä¹…æ‰èƒ½ä½¿æ‰€æœ‰èŠ‚ç‚¹éƒ½æ”¶åˆ°ä¿¡å·ï¼Ÿå¦‚æœä¸èƒ½ä½¿æ‰€æœ‰èŠ‚ç‚¹æ”¶åˆ°ä¿¡å·ï¼Œè¿”å› `-1`ã€‚ 

> **ç¤ºä¾‹ï¼š**

<img src="_img/743.png" style="zoom:100%"/>

```
è¾“å…¥ï¼štimes = [[2,1,1],[2,3,1],[3,4,1]], N = 4, K = 2
è¾“å‡ºï¼š2 
```

**æ³¨æ„:**

1. `N` çš„èŒƒå›´åœ¨ `[1, 100]` ä¹‹é—´ã€‚
2. `K` çš„èŒƒå›´åœ¨ `[1, N]` ä¹‹é—´ã€‚
3. `times` çš„é•¿åº¦åœ¨ `[1, 6000]` ä¹‹é—´ã€‚
4. æ‰€æœ‰çš„è¾¹ `times[i] = (u, v, w)` éƒ½æœ‰ `1 <= u, v <= N` ä¸” `0 <= w <= 100`ã€‚

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/network-delay-time/>

#### **æ€è·¯:**

ã€€ã€€ç”±äºè¾¹çš„æƒæ˜¯ä¸åŒçš„**æ­£æ•°**ï¼Œè¯¥é¢˜æ˜¯ä¸å«è´Ÿç¯çš„**å•æºæœ€çŸ­è·¯å¾„**é—®é¢˜ã€‚  

ã€€ã€€Dijkstraç®—æ³•æ˜¯ç”¨æ¥æ±‚å•æºæœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œå³ç»™å®šå›¾Gå’Œèµ·ç‚¹sï¼Œé€šè¿‡ç®—æ³•å¾—åˆ°såˆ°è¾¾å…¶ä»–æ¯ä¸ªé¡¶ç‚¹çš„æœ€çŸ­è·ç¦»ã€‚

ã€€ã€€åŸºæœ¬æ€æƒ³ï¼šå¯¹å›¾`G(V,E)`è®¾ç½®é›†åˆ`S`ï¼Œå­˜æ”¾å·²è¢«è®¿é—®çš„é¡¶ç‚¹ï¼Œç„¶åæ¯æ¬¡ä»é›†åˆ`V-S`ä¸­é€‰æ‹©ä¸èµ·ç‚¹sçš„æœ€çŸ­è·ç¦»æœ€å°çš„ä¸€ä¸ªé¡¶ç‚¹ï¼ˆè®°ä¸ºuï¼‰ï¼Œè®¿é—®å¹¶åŠ å…¥é›†åˆ`S`ã€‚ä¹‹åï¼Œä»¤uä¸ºä¸­ä»‹ç‚¹ï¼Œä¼˜åŒ–èµ·ç‚¹sä¸æ‰€æœ‰ä»uèƒ½å¤Ÿåˆ°è¾¾çš„é¡¶ç‚¹vä¹‹é—´çš„æœ€çŸ­è·ç¦»ã€‚è¿™æ ·çš„æ“ä½œæ‰§è¡Œnæ¬¡ï¼ˆnä¸ºé¡¶ç‚¹ä¸ªæ•°ï¼‰ï¼Œç›´åˆ°é›†åˆ`S`å·²ç»åŒ…å«æ‰€æœ‰é¡¶ç‚¹ã€‚ã€€

#### **ä»£ç :**

```python
from collections import defaultdict

class Solution:
    def networkDelayTime(self, times: List[List[int]], N: int, K: int) -> int:
        edge = defaultdict(list)  # edge[1] = (t, 2)
        for u, v, w in times:
            edge[u].append((w, v))

        minimal = [float('inf') for _ in range(N + 1)]
        minimal[K] = 0
        S = {K} # èµ·ç‚¹
        VS = edge[K]
        for t, node in edge[K]:
            minimal[node] = t

        while VS:
            t, u = min(VS)
            VS.remove((t, u))
            S.add(u)
            for path in edge[u]:
                if path[1] not in S:
                    VS.append(path)  # é˜²æ­¢å‡ºç°ç¯
            for t, node in edge[u]:
                minimal[node] = min(minimal[node], minimal[u] + t)  # ç»è¿‡uä¸ºä¸­ä»‹

        # print(minimal)
        ans = max(minimal[1:])
        return ans if ans != float('inf') else -1

```

## A752. æ‰“å¼€è½¬ç›˜é”

éš¾åº¦`ä¸­ç­‰`

#### é¢˜ç›®æè¿°

ä½ æœ‰ä¸€ä¸ªå¸¦æœ‰å››ä¸ªåœ†å½¢æ‹¨è½®çš„è½¬ç›˜é”ã€‚æ¯ä¸ªæ‹¨è½®éƒ½æœ‰10ä¸ªæ•°å­—ï¼š `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` ã€‚æ¯ä¸ªæ‹¨è½®å¯ä»¥è‡ªç”±æ—‹è½¬ï¼šä¾‹å¦‚æŠŠ `'9'` å˜ä¸º  `'0'`ï¼Œ`'0'` å˜ä¸º `'9'` ã€‚æ¯æ¬¡æ—‹è½¬éƒ½åªèƒ½æ—‹è½¬ä¸€ä¸ªæ‹¨è½®çš„ä¸€ä½æ•°å­—ã€‚

é”çš„åˆå§‹æ•°å­—ä¸º `'0000'` ï¼Œä¸€ä¸ªä»£è¡¨å››ä¸ªæ‹¨è½®çš„æ•°å­—çš„å­—ç¬¦ä¸²ã€‚

åˆ—è¡¨ `deadends` åŒ…å«äº†ä¸€ç»„æ­»äº¡æ•°å­—ï¼Œä¸€æ—¦æ‹¨è½®çš„æ•°å­—å’Œåˆ—è¡¨é‡Œçš„ä»»ä½•ä¸€ä¸ªå…ƒç´ ç›¸åŒï¼Œè¿™ä¸ªé”å°†ä¼šè¢«æ°¸ä¹…é”å®šï¼Œæ— æ³•å†è¢«æ—‹è½¬ã€‚

å­—ç¬¦ä¸² `target` ä»£è¡¨å¯ä»¥è§£é”çš„æ•°å­—ï¼Œä½ éœ€è¦ç»™å‡ºæœ€å°çš„æ—‹è½¬æ¬¡æ•°ï¼Œå¦‚æœæ— è®ºå¦‚ä½•ä¸èƒ½è§£é”ï¼Œè¿”å› -1ã€‚

> **ç¤ºä¾‹ 1:**

```
è¾“å…¥ï¼šdeadends = ["0201","0101","0102","1212","2002"], target = "0202"
è¾“å‡ºï¼š6
è§£é‡Šï¼š
å¯èƒ½çš„ç§»åŠ¨åºåˆ—ä¸º "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"ã€‚
æ³¨æ„ "0000" -> "0001" -> "0002" -> "0102" -> "0202" è¿™æ ·çš„åºåˆ—æ˜¯ä¸èƒ½è§£é”çš„ï¼Œ
å› ä¸ºå½“æ‹¨åŠ¨åˆ° "0102" æ—¶è¿™ä¸ªé”å°±ä¼šè¢«é”å®šã€‚
```

> **ç¤ºä¾‹ 2:**

```
è¾“å…¥: deadends = ["8888"], target = "0009"
è¾“å‡ºï¼š1
è§£é‡Šï¼š
æŠŠæœ€åä¸€ä½åå‘æ—‹è½¬ä¸€æ¬¡å³å¯ "0000" -> "0009"ã€‚
```

> **ç¤ºä¾‹ 3:**

```
è¾“å…¥: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
è¾“å‡ºï¼š-1
è§£é‡Šï¼š
æ— æ³•æ—‹è½¬åˆ°ç›®æ ‡æ•°å­—ä¸”ä¸è¢«é”å®šã€‚
```

> **ç¤ºä¾‹ 4:**

```
è¾“å…¥: deadends = ["0000"], target = "8888"
è¾“å‡ºï¼š-1
```

**æç¤ºï¼š**

1. æ­»äº¡åˆ—è¡¨ `deadends` çš„é•¿åº¦èŒƒå›´ä¸º `[1, 500]`ã€‚
2. ç›®æ ‡æ•°å­— `target` ä¸ä¼šåœ¨ `deadends` ä¹‹ä¸­ã€‚
3. æ¯ä¸ª `deadends` å’Œ `target` ä¸­çš„å­—ç¬¦ä¸²çš„æ•°å­—ä¼šåœ¨ 10,000 ä¸ªå¯èƒ½çš„æƒ…å†µ `'0000'` åˆ° `'9999'` ä¸­äº§ç”Ÿã€‚

#### é¢˜ç›®é“¾æ¥

<https://leetcode-cn.com/problems/open-the-lock/>

#### **æ€è·¯:**

ã€€ã€€æœ€çŸ­è·¯å¾„é—®é¢˜ï¼Œå››ä½æ•°å­—(æ­£åè½¬)ç›¸å½“äº`8ä¸ªæ–¹å‘`ï¼Œ`deadends`ç›¸å½“äºéšœç¢ç‰©ã€‚å¥—ç”¨bfsæ¨¡æ¿ã€‚  

ã€€ã€€éœ€è¦æ³¨æ„çš„æ˜¯ç›¸é‚»æ•°å­—çš„å¤„ç†ï¼Œç”±äº`Python3`å–æ¨¡çš„ç»“æœä¸€å®šæ˜¯æ­£æ•°ï¼Œä¹Ÿå°±æ˜¯`-1 % 10 = 9`ï¼Œæ‰€ä»¥å¯ä»¥ç”¨å–æ¨¡æ¥ç®€åŒ–ä»£ç ã€‚å››ä½æ•°å­—ä¸­çš„ä»»æ„ä¸€ä½`Â±1`ç„¶å`%10`å°±å¯ä»¥å¾—åˆ°ä¸‹ä¸€ç§å¯èƒ½æ€§ã€‚  

#### **ä»£ç :**

```python
class Solution:
    def openLock(self, deadends: List[str], target: str) -> int:
        if '0000' in deadends: return -1
        target = int(target)
        can_go = [True for _ in range(10000)]
        visted = [False for _ in range(10000)]
        for d in deadends:
            can_go[int(d)] = False

        arounds = [1, -1]

        queue = [0]
        visted[0] = True
        ans = 0
        while queue:
            for q in queue:
                if q == target:
                    return ans

            ans += 1
            temp = []
            for q in queue:
                for i in range(8):
                    # è·å–ä¸‹ä¸€ä¸ªå¯èƒ½çš„ä½ç½®
                    digits = [q // 1000, q % 1000 // 100, (q % 100) // 10, q % 10]
                    digits[i//2] = (digits[i//2] + arounds[i%2]) % 10  # æŸä½æ•°å­—åŠ å‡1
                    a, b, c, d = digits
                    nxt = a * 1000 + b * 100 + c * 10 + d
                    if can_go[nxt] and not visted[nxt]:
                        visted[nxt] = True
                        temp.append(nxt)

            queue = temp

        return -1
      
```





