# Python 常用算法模板


## 排序和搜索

### 主次关键词排序

```python
speed = [1, 2, 3, 4]
efficiency = [4, 1, 2, 3]
z = list(zip(speed, efficiency))
s = sorted(z, key=lambda kv: (kv[1], kv[0]), reverse=True)
# s = [(1,4), (4,3), (3,2), (2,1)]

```


### 快速排序的partition函数

```python
def partition(nums, low, high):
    pivot = nums[low]
    while low < high:
        while low < high and nums[high] >= pivot:
            high -= 1
        nums[low] = nums[high]
        while low < high and nums[low] <= pivot:
            low += 1
        nums[high] = nums[low]
    
    nums[low]=pivot
    return low
  
# partition(arr, 0, len(arr)-1))

```

### 快速排序

```python
def quick_sort(nums, low, high):
    if low >= high:
        return
    i = partition(nums, low, high)
    quick_sort(nums, low, i-1)
    quick_sort(nums, i+1, high)
    
# quick_sort(arr, 0, len(arr)-1))

```

### 堆

```python
# 插入新元素以及查找最小元素复杂度均为logn
import heapq

heap = []
heapq.heappush(heap, 2)
heapq.heappush(heap, 1)

if heap:
	heap_min = heapq.heappop(heap)  # 弹出最小的值

```

### 二分查找(非递归)

```python
def search(nums):
    i, j = 0, len(nums)
    while i <= j and i < len(nums):
        mid = (i + j) // 2
        if nums[mid] > target:
            j = mid - 1
        elif nums[mid] < target:
            i = mid + 1
        else:
            return mid if nums[mid] == target else -1
          
    return -1
```
### 深搜：dfs先循环后判断

```python
def dfs(n, target, cur):
    for i in range(n, l):  # 先循环
        if target == candidates[i]:  # 循环内判断
            ans.append(cur + [candidates[i]])
            return
        cur.append(candidates[i])
        dfs(i + 1, target - candidates[i], cur)
        cur.remove(candidates[i])

dfs(0, target, [])

```

### 深搜：dfs先判断后循环

```python
def dfs(n, target, cur):
    nonlocal l
    if target < 0:
        return

    if target == 0:  # 先判断
        ans.append(cur.copy())
        return

    for i in range(n + 1, l):  # 后循环
        cur.append(candidates[i])
        dfs(i, target - candidates[i], cur)
        cur.remove(candidates[i])

```

### 深搜：dfs(去除重复❌)

```python
# 1 2 2 2  去除重复的122
nums.sort()
ans = []
l = len(nums)
def dfs(n, temp):
    ans.append(temp.copy())
    nonlocal l
    for i in range(n, l):
        if i == n or nums[i] != nums[i-1]:  # 除了第一个元素外，不使用和上一个重复的元素。
            temp.append(nums[i])
            dfs(i+1, temp)
            temp.remove(nums[i])

dfs(0, [])
return ans
```

### 深搜：dfs(迷宫、路径)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右
# matrix = grid = board
m = len(matrix)
if not m: return 0
n = len(matrix[0])

visited = [[False for _ in range(n)] for _ in range(m)]
ans = 0

def dfs(i, j, depth=0):   
    nonlocal ans
    if i < 0 or j < 0 or i >= m or j >= n:  # 边界
        return 

    if visited[i][j] or matrix[i][j] == 'X':  # 不能走
        return

    visited[i][j] = True
    depth = depth + 1  # 加完1之后是真正的深度
    # ans = max(ans, depth)  # 在这里更新ans
    
    for di, dj in arounds:
        dfs(i + di,j + dj, depth) 

    visited[i][j] = False
    
dfs(0, 0)
```



### 广搜：bfs(找出所有路径)

```python
queue = [beginWord]
visited[beginWord] = True

while queue:
    for q in queue:
        if q == endWord:
            return paths[endWord]  # 到达终点

    temp = []
    for q in queue:
        for neibour in get_edges(q):  # 所有相邻的路径
            if not visited[neibour]:
                if neibour not in temp:
                    visited[neibour] = True
                    temp.append(neibour)

                # for path in paths[q]:  # 记录回溯信息
                #     paths[neibour].append(path + [neibour])

    queue = temp

return []  # 无法到达终点

```

### 广搜：bfs(腐烂的橘子🍊)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右
grid = matrix
m = len(matrix)
if not m: return []
n = len(matrix[0])

temp = []

def rot(x, y):
    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):
        return False
    if grid[x][y] != 0:  # 成功腐烂新鲜的橘子，返回True
        grid[x][y] = 0  
        temp.append((x, y))
        return True
    return False

depth = 0
queue = []
for i in range(m):
    for j in range(n):
        if grid[i][j] == 0:  # 刚开始腐烂的橘子
            queue.append((i, j))

while queue: 
    temp = []
    for i, j in queue:
        for di, dj in arounds:
            rot(i + di, j + dj)

    depth += 1

    queue = temp

return ans
```

### 广搜：bfs(🌲层序遍历)

```python
#def level_traversal(root):
    if not root:
        return 
        
    queue = [root]
    ans = []
    while queue:
        temp = []
        # queue存放的是当前层的所有结点
        for q in queue:
            if q.left:
                temp.append(q.left)
            if q.right:
                temp.append(q.right)
        
        queue = temp
    return ans
```

### 广搜：bfs(迷宫、最短路径)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 上下左右
m = len(matrix)
if not m: return 0
n = len(matrix[0])

visited = [[False for _ in range(n)] for _ in range(m)]

queue = [(0, 0)]  # 起始位置
visited[0][0] = True

count = 0
while queue:
    for i, j in queue:
        if i == m - 1 and j == n - 1:
            return count  # 结束的条件
        
    count += 1

    temp = []
    for i, j in queue:
        for di, dj in arounds:
            x, y = i + di, j + dj
            if x < 0 or y < 0 or x >= m or y >= n:  # 边界
                continue
            if not visited[x][y]:
                visited[x][y] = True
                temp.append((x, y))

    queue = temp

```

## 字符串


### KMP的next数组

```python
def get_next(t):
    j, k = 0, -1
    n = len(t)
    next = [-1 for i in range(n+1)]
    while j < n:
        if k == -1 or t[j] == t[k]:
            j += 1
            k += 1
            next[j] = k
        else:
            k = next[k]
    return next
  
# t = "ababab"
# get_next(t) = [-1, 0, 0, 1, 2, 3, 4]
```

### KMP模板匹配

```python
def kmp(s: str, t: str) -> int:
    next = get_next(t)
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if j == -1 or s[i] == t[j]:
            i += 1
            j += 1
        else:
            j = next[j]
    if j >= len(t):
        return i - len(t)
    else:
        return -1

# kmp('abdeabcd', 'abc')) = 4
# kmp('abde', 'abc') = -1
```

### 最长公共前后缀

```python
#  "aaabxeaaab" = 4
class Solution:
    def longestPrefix(self, s: str) -> str:
        j, k = 0, -1
        n = len(s)
        next = [-1 for i in range(n+1)]
        while j < n:
            if k == -1 or s[j] == s[k]:
                j += 1
                k += 1
                next[j] = k
            else:
                k = next[k]

        return s[:next[n]]
```

### 最长回文子串(马拉车算法)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        s = '#' + '#'.join(s) + '#' # 字符串处理，用特殊字符隔离字符串，方便处理偶数子串
        lens = len(s)
        p = [0] * lens            # p[i]表示i作中心的最长回文子串的半径，初始化p[i]
        mx = 0                    # 之前最长回文子串的右边界
        id = 0                    # 之前最长回文子串的中心位置
        for i in range(lens):     # 遍历字符串
            if mx > i:
                p[i] = min(mx-i, p[int(2*id-i)]) #由理论分析得到
            else :                # mx <= i
                p[i] = 1
            while i-p[i] >= 0 and i+p[i] < lens and s[i-p[i]] == s[i+p[i]]:  # 满足回文条件的情况下
                p[i] += 1  # 两边扩展
            if(i+p[i]) > mx:  # 新子串右边界超过了之前最长子串右边界
                mx, id = i+p[i], i # 移动之前最长回文子串的中心位置和边界，继续向右匹配
        i_res = p.index(max(p)) # 获取最终最长子串中心位置
        s_res = s[i_res-(p[i_res]-1):i_res+p[i_res]] #获取最终最长子串，带"#"
        return s_res.replace('#', '')  # 长度为：max(p)-1
```

### 字典树(Trie)

```python
# words = ['abcd', 'acd', 'ace', 'bc']
trie = {}  # 构造字典树
for i, word in enumerate(words):
    node = trie
    for char in word:
        node = node.setdefault(char, {})
    node['#'] = i
            
# 搜索字典树
tmp = trie
for char in s:
    tmp = tmp[char]
    if "#" in tmp:
        return True  # 找到了
```

## 数学


### 排列与组合

```python
def factor(num):
    if num < 2:
        return 1
    res = 1
    for i in range(1, num+1):
        res *= i
    return res

def A(m, n):
    return factor(m) // factor(m-n)

def C(m, n):
    return A(m, n) // factor(n)
  
# C(5, 3) = (5×4×3)//(3×2×1) = 10
```

### 最大公约数(辗转相除法)

```python
def gcd(a, b):
    if a < b:
        a, b = b, a  # 确保大的在前面
    while b != 0:
        a, b = b, a % b
    return a
```
## 图和树🌲


### 有序数组构建平衡二叉树

```python
def build(self, nums, i, j):
    mid = (i+j)//2
    root = TreeNode(nums[mid])
    if(i==j):
        return root
    if i <= mid-1:
        root.left = self.build(nums,i,mid-1)
    if mid+1 <= j:
        root.right = self.build(nums, mid+1, j)

    return root
  
```

### dijskra(单源最短路径)

```python
# 图中不能含有负环
v = [0] + [float('inf')] * N  # 结点下标从1开始
v[K], q = 0, {K}  # K是起始node
while q:
    t = set()
    for i in q:
        for j in d[i]:
            if v[i] + d[i][j] < v[j]:
                v[j] = v[i] + d[i][j]
                t.add(j)
    q = t
ans = max(v)  # v是最终结果
```

### 欧拉路径(一笔画问题)

```python
stack = ['JFK']  # 初始位置
ans = []
while stack:
    curr = stack[-1]  # peek
    if edges[curr]:  # edges = {'JFK': ['SFO', 'ATL']}
        next = min(edges[curr])
        edges[curr].remove(next)
        stack.append(next)
    else:
        ans.append(curr)
        stack.pop()

return ans[::-1]
```

