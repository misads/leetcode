# Python 实用模板

## 创建矩阵

```python
# 创建m×n的矩阵
m = [[0 for i in range(n)] for j in range(m)]

```

## 关键词排序

```python
speed = [1, 2, 3, 4]
efficiency = [4, 1, 2, 3]
z = list(zip(speed, efficiency))
s = sorted(z, key=lambda kv: (kv[1], kv[0]), reverse=True)
# s = [(1,4), (4,3), (3,2), (2,1)]

```
## 堆(插入新元素以及查找最小元素复杂度均为logn)

```python
import heapq

heap = []
heapq.heappush(heap, 2)
heapq.heappush(heap, 1)

if heap:
	heap_min = heapq.heappop(heap)  # 弹出最小的值

```

## 二分查找(非递归)

```python
def search(nums):
    i, j = 0, len(nums)
    while i <= j and i < len(nums):
        mid = (i + j) // 2
        if nums[mid] > target:
            j = mid - 1
        elif nums[mid] < target:
            i = mid + 1
        else:
            return mid if nums[mid] == target else -1
          
    return -1
```
## dfs先循环后判断

```python
def dfs(n, target, cur):
    for i in range(n, l):  # 先循环
        if target == candidates[i]:  # 循环内判断
            ans.append(cur + [candidates[i]])
            return
        cur.append(candidates[i])
        dfs(i + 1, target - candidates[i], cur)
        cur.remove(candidates[i])

dfs(0, target, [])

```

## dfs先判断后循环

```python
def dfs(n, target, cur):
    nonlocal l
    if target < 0:
        return

    if target == 0:  # 先判断
        ans.append(cur.copy())
        return

    for i in range(n + 1, l):  # 后循环
        cur.append(candidates[i])
        dfs(i, target - candidates[i], cur)
        cur.remove(candidates[i])

```

## 快速排序的partition函数

```python
def partition(nums, low, high):
    pivot = nums[low]
    while low < high:
        while low < high and nums[high] >= pivot:
            high -= 1
        nums[low] = nums[high]
        while low < high and nums[low] <= pivot:
            low += 1
        nums[high] = nums[low]
    
    nums[low]=pivot
    return low
  
# partition(arr, 0, len(arr)-1))

```

## 快速排序

```python
def quick_sort(nums, low, high):
    if low >= high:
        return
    i = partition(nums, low, high)
    quick_sort(nums, low, i-1)
    quick_sort(nums, i+1, high)
    
# quick_sort(arr, 0, len(arr)-1))

```

## 排列与组合

```python
def factor(num):
    if num < 2:
        return 1
    res = 1
    for i in range(1, num+1):
        res *= i
    return res

def A(m, n):
    return factor(m) // factor(m-n)

def C(m, n):
    return A(m, n) // factor(n)
  
# C(5, 3) = (5×4×3)//(3×2×1) = 10
```

