# Python å¸¸ç”¨ç®—æ³•æ¨¡æ¿


## æ’åºå’Œæœç´¢

### ä¸»æ¬¡å…³é”®è¯æ’åº

```python
speed = [1, 2, 3, 4]
efficiency = [4, 1, 2, 3]
z = list(zip(speed, efficiency))
s = sorted(z, key=lambda kv: (kv[1], kv[0]), reverse=True)
# s = [(1,4), (4,3), (3,2), (2,1)]

```


### å¿«é€Ÿæ’åºçš„partitionå‡½æ•°

```python
def partition(nums, low, high):
    pivot = nums[low]
    while low < high:
        while low < high and nums[high] >= pivot:
            high -= 1
        nums[low] = nums[high]
        while low < high and nums[low] <= pivot:
            low += 1
        nums[high] = nums[low]
    
    nums[low]=pivot
    return low
  
# partition(arr, 0, len(arr)-1))

```

### å¿«é€Ÿæ’åº

```python
def quick_sort(nums, low, high):
    if low >= high:
        return
    i = partition(nums, low, high)
    quick_sort(nums, low, i-1)
    quick_sort(nums, i+1, high)
    
# quick_sort(arr, 0, len(arr)-1))

```

### å †

```python
# æ’å…¥æ–°å…ƒç´ ä»¥åŠæŸ¥æ‰¾æœ€å°å…ƒç´ å¤æ‚åº¦å‡ä¸ºlogn
import heapq

heap = []
heapq.heappush(heap, 2)
heapq.heappush(heap, 1)

if heap:
	heap_min = heapq.heappop(heap)  # å¼¹å‡ºæœ€å°çš„å€¼

```

### äºŒåˆ†æŸ¥æ‰¾(éé€’å½’)

```python
def search(nums):
    i, j = 0, len(nums)
    while i <= j and i < len(nums):
        mid = (i + j) // 2
        if nums[mid] > target:
            j = mid - 1
        elif nums[mid] < target:
            i = mid + 1
        else:
            return mid if nums[mid] == target else -1
          
    return -1
```
### æ·±æœï¼šdfså…ˆå¾ªç¯ååˆ¤æ–­

```python
def dfs(n, target, cur):
    for i in range(n, l):  # å…ˆå¾ªç¯
        if target == candidates[i]:  # å¾ªç¯å†…åˆ¤æ–­
            ans.append(cur + [candidates[i]])
            return
        cur.append(candidates[i])
        dfs(i + 1, target - candidates[i], cur)
        cur.remove(candidates[i])

dfs(0, target, [])

```

### æ·±æœï¼šdfså…ˆåˆ¤æ–­åå¾ªç¯

```python
def dfs(n, target, cur):
    nonlocal l
    if target < 0:
        return

    if target == 0:  # å…ˆåˆ¤æ–­
        ans.append(cur.copy())
        return

    for i in range(n + 1, l):  # åå¾ªç¯
        cur.append(candidates[i])
        dfs(i, target - candidates[i], cur)
        cur.remove(candidates[i])

```

### æ·±æœï¼šdfså»é™¤é‡å¤

```python
# 1 2 2 2  ä¸å»é‡æœ‰å¤šä¸ª 122
nums.sort()
ans = []
l = len(nums)
def dfs(n, temp):
    ans.append(temp.copy())
    nonlocal l
    for i in range(n, l):
        if i == n or nums[i] != nums[i-1]:  # é™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ å¤–ï¼Œä¸ä½¿ç”¨å’Œä¸Šä¸€ä¸ªé‡å¤çš„å…ƒç´ ã€‚
            temp.append(nums[i])
            dfs(i+1, temp)
            temp.remove(nums[i])

dfs(0, [])
return ans
```

### æ·±æœï¼šdfsè¿·å®«ã€è·¯å¾„é¢˜æ¨¡æ¿

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
# matrix = grid = board
m = len(matrix)
if not m: return 0
n = len(matrix[0])

visited = [[False for _ in range(n)] for _ in range(m)]
ans = 0

def dfs(i, j, depth=0):   
    nonlocal ans
    if i < 0 or j < 0 or i >= m or j >= n:  # è¾¹ç•Œ
        return 

    if visited[i][j] or matrix[i][j] == 'X':  # ä¸èƒ½èµ°
        return

    visited[i][j] = True
    depth = depth + 1  # åŠ å®Œ1ä¹‹åæ˜¯çœŸæ­£çš„æ·±åº¦
    # ans = max(ans, depth)  # åœ¨è¿™é‡Œæ›´æ–°ans
    
    for di, dj in arounds:
        dfs(i + di,j + dj, depth) 

    visited[i][j] = False
    
dfs(0, 0)
```

### å¹¿æœï¼šbfs(æœ€çŸ­è·¯å¾„)

```python
q = [(0, 0)]

while True:
    for i, j in q:
        for di, d in enumerate(directions):
            if grid[i][j] == di + 1:  # ç®­å¤´çš„æ–¹å‘
                x = i + d[0]
                y = j + d[1]
                if can_go(x, y):
                    q.append((x, y))
                    print(x, y)
                    visited.add((x, y))  # ï¼ï¼æ ‡è®°å·²ç»èµ°è¿‡äº†ï¼ï¼

    if (m - 1, n - 1) in visited:
        return count  # ç»“æŸçš„æ¡ä»¶

    count += 1

    new_q = []
    for i, j in q:
        for di, d in enumerate(directions):
            x = i + d[0]
            y = j + d[1]
            if (x, y) not in visited and can_go(x, y):
                new_q.append((x, y))
                visited.add((x, y))

    del q
    q = new_q
```

### å¹¿æœï¼šbfs(æ‰€æœ‰è·¯å¾„)

```python
queue = [beginWord]
while queue:
    for q in queue:
        visited[q] = True  # æ‰€æœ‰çš„éƒ½æ ‡è®°ä¸ºèµ°è¿‡

    temp = []
    for q in queue:
        if q == endWord:
            return paths[endWord]  # åˆ°è¾¾ç»ˆç‚¹

        for neibour in get_edges(q):  # æ‰€æœ‰ç›¸é‚»çš„è·¯å¾„
            if not visited[neibour]:
                if neibour not in temp:
                    temp.append(neibour)

                # for path in paths[q]:  # è®°å½•å›æº¯ä¿¡æ¯
                #     paths[neibour].append(path + [neibour])

    queue = temp

return []  # æ— æ³•åˆ°è¾¾ç»ˆç‚¹

```

### å¹¿æœï¼šbfs(è…çƒ‚çš„æ©˜å­ğŸŠ)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³

new_rotting = []

def rot(x, y):
    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):
        return False
    if grid[x][y] == 1:
        grid[x][y] = 2  # æˆåŠŸè…çƒ‚æ–°é²œçš„æ©˜å­ï¼Œè¿”å›True
        new_rotting.append((x, y))
        return True

    return False

ans = 0

while True:
    new_rotting.clear()
    has_new_rotting = False  # è¿™ä¸€è½®æ˜¯å¦è…çƒ‚äº†æ–°çš„æ©˜å­
    for i, j in rottings:
        for i1, j1 in arounds:
            if rot(i + i1, j + j1):
                has_new_rotting = True

    if not has_new_rotting:
        for line in grid:
            if line.count(1) != 0:
                return -1
        return ans

    rottings = new_rotting.copy()
    ans += 1
```

### å¹¿æœï¼šbfså±‚åºéå†æ¨¡æ¿

```python
def level_traversal(root):
    if not root:
        return 
        
    queue = [root]
    while queue:
        temp = []
        # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
        for q in queue:
            if q.left:
                temp.append(q.left)
            if q.right:
                temp.append(q.right)
        
        queue = temp
    return ans
```

## å­—ç¬¦ä¸²


### KMPçš„nextæ•°ç»„

```python
def get_next(t):
    j, k = 0, -1
    n = len(t)
    next = [-1 for i in range(n+1)]
    while j < n:
        if k == -1 or t[j] == t[k]:
            j += 1
            k += 1
            next[j] = k
        else:
            k = next[k]
    return next
  
# t = "ababab"
# get_next(t) = [-1, 0, 0, 1, 2, 3, 4]
```

### KMPæ¨¡æ¿åŒ¹é…

```python
def kmp(s: str, t: str) -> int:
    next = get_next(t)
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if j == -1 or s[i] == t[j]:
            i += 1
            j += 1
        else:
            j = next[j]
    if j >= len(t):
        return i - len(t)
    else:
        return -1

# kmp('abdeabcd', 'abc')) = 4
# kmp('abde', 'abc') = -1
```

### æœ€é•¿å…¬å…±å‰åç¼€

```python
#  "aaabxeaaab" = 4
class Solution:
    def longestPrefix(self, s: str) -> str:
        j, k = 0, -1
        n = len(s)
        next = [-1 for i in range(n+1)]
        while j < n:
            if k == -1 or s[j] == s[k]:
                j += 1
                k += 1
                next[j] = k
            else:
                k = next[k]

        return s[:next[n]]
```

### æœ€é•¿å›æ–‡å­ä¸²(é©¬æ‹‰è½¦ç®—æ³•)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        s = '#' + '#'.join(s) + '#' # å­—ç¬¦ä¸²å¤„ç†ï¼Œç”¨ç‰¹æ®Šå­—ç¬¦éš”ç¦»å­—ç¬¦ä¸²ï¼Œæ–¹ä¾¿å¤„ç†å¶æ•°å­ä¸²
        lens = len(s)
        p = [0] * lens            # p[i]è¡¨ç¤ºiä½œä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²çš„åŠå¾„ï¼Œåˆå§‹åŒ–p[i]
        mx = 0                    # ä¹‹å‰æœ€é•¿å›æ–‡å­ä¸²çš„å³è¾¹ç•Œ
        id = 0                    # ä¹‹å‰æœ€é•¿å›æ–‡å­ä¸²çš„ä¸­å¿ƒä½ç½®
        for i in range(lens):     # éå†å­—ç¬¦ä¸²
            if mx > i:
                p[i] = min(mx-i, p[int(2*id-i)]) #ç”±ç†è®ºåˆ†æå¾—åˆ°
            else :                # mx <= i
                p[i] = 1
            while i-p[i] >= 0 and i+p[i] < lens and s[i-p[i]] == s[i+p[i]]:  # æ»¡è¶³å›æ–‡æ¡ä»¶çš„æƒ…å†µä¸‹
                p[i] += 1  # ä¸¤è¾¹æ‰©å±•
            if(i+p[i]) > mx:  # æ–°å­ä¸²å³è¾¹ç•Œè¶…è¿‡äº†ä¹‹å‰æœ€é•¿å­ä¸²å³è¾¹ç•Œ
                mx, id = i+p[i], i # ç§»åŠ¨ä¹‹å‰æœ€é•¿å›æ–‡å­ä¸²çš„ä¸­å¿ƒä½ç½®å’Œè¾¹ç•Œï¼Œç»§ç»­å‘å³åŒ¹é…
        i_res = p.index(max(p)) # è·å–æœ€ç»ˆæœ€é•¿å­ä¸²ä¸­å¿ƒä½ç½®
        s_res = s[i_res-(p[i_res]-1):i_res+p[i_res]] #è·å–æœ€ç»ˆæœ€é•¿å­ä¸²ï¼Œå¸¦"#"
        return s_res.replace('#', '')  # é•¿åº¦ä¸ºï¼šmax(p)-1
```

### å­—å…¸æ ‘(Trie)

```python
# words = ['abcd', 'acd', 'ace', 'bc']
trie = {}  # æ„é€ å­—å…¸æ ‘
for i, word in enumerate(words):
    node = trie
    for char in word:
        node = node.setdefault(char, {})
    node['#'] = i
            
# æœç´¢å­—å…¸æ ‘
tmp = trie
for char in s:
    tmp = tmp[char]
    if "#" in tmp:
        return True  # æ‰¾åˆ°äº†
```

## æ•°å­¦


### æ’åˆ—ä¸ç»„åˆ

```python
def factor(num):
    if num < 2:
        return 1
    res = 1
    for i in range(1, num+1):
        res *= i
    return res

def A(m, n):
    return factor(m) // factor(m-n)

def C(m, n):
    return A(m, n) // factor(n)
  
# C(5, 3) = (5Ã—4Ã—3)//(3Ã—2Ã—1) = 10
```

### æœ€å¤§å…¬çº¦æ•°(è¾—è½¬ç›¸é™¤æ³•)

```python
def gcd(a, b):
    if a < b:
        a, b = b, a  # ç¡®ä¿å¤§çš„åœ¨å‰é¢
    while b != 0:
        a, b = b, a % b
    return a
```
## å›¾å’Œæ ‘ğŸŒ²


### æœ‰åºæ•°ç»„æ„å»ºå¹³è¡¡äºŒå‰æ ‘

```python
def build(self, nums, i, j):
    mid = (i+j)//2
    root = TreeNode(nums[mid])
    if(i==j):
        return root
    if i <= mid-1:
        root.left = self.build(nums,i,mid-1)
    if mid+1 <= j:
        root.right = self.build(nums, mid+1, j)

    return root
  
```

### æ¬§æ‹‰è·¯å¾„(ä¸€ç¬”ç”»é—®é¢˜)

```python
stack = ['JFK']  # åˆå§‹ä½ç½®
ans = []
while stack:
    curr = stack[-1]  # peek
    if edges[curr]:  # edges = {'JFK': ['SFO', 'ATL']}
        next = min(edges[curr])
        edges[curr].remove(next)
        stack.append(next)
    else:
        ans.append(curr)
        stack.pop()

return ans[::-1]
```

