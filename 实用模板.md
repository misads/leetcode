# Python å¸¸ç”¨ç®—æ³•æ¨¡æ¿


## æ’åºå’Œæœç´¢

### ä¸»æ¬¡å…³é”®è¯æ’åº

```python
speed = [1, 2, 3, 4]
efficiency = [4, 1, 2, 3]
z = list(zip(speed, efficiency))
s = sorted(z, key=lambda kv: (kv[1], kv[0]), reverse=True)
# s = [(1,4), (4,3), (3,2), (2,1)]

```

### è‡ªå®šä¹‰æ¯”è¾ƒå‡½æ•°

```python
from functools import cmp_to_key

def cmpp(s1, s2):
    if s1 > s2:
        return 1
    if s1 < s2:
        return -1
      
a = [5, 4, 3, 2, 1]
a.sort(key=cmp_to_key(cmpp))
# [1, 2, 3, 4, 5]

```

### å¿«é€Ÿæ’åºçš„partitionå‡½æ•°

```python
def partition(nums, left, right, pivot_index=None):
    if pivot_index is None:  # pivot_index å–å€¼èŒƒå›´[left, right]
        pivot_index = left
    pivot = nums[pivot_index]
    nums[pivot_index], nums[right] = nums[right], nums[pivot_index]

    store_index = left
    for i in range(left, right):
        if nums[i] < pivot:
            nums[store_index], nums[i] = nums[i], nums[store_index]
            store_index += 1
    nums[right], nums[store_index] = nums[store_index], nums[right]

    return store_index

# p = random.randint(0, len(arr)-1)
# partition(arr, 0, len(arr)-1, p)

```

### å¿«é€Ÿæ’åº

```python
def quick_sort(nums, low, high):
    if low >= high:
        return
    i = partition(nums, low, high)
    quick_sort(nums, low, i-1)
    quick_sort(nums, i+1, high)
    
# quick_sort(arr, 0, len(arr)-1)

```

### å½’å¹¶æ’åº

```python
# é€‚ç”¨äºé€†åºå¯¹ æ’åºé“¾è¡¨ç­‰é—®é¢˜
def merge(nums, start, end):
    m = (start + end) // 2
    left, right = nums[start:m + 1], nums[m + 1:end + 1]
    left.append(float('inf'))
    right.append(float('inf'))

    il, ir = 0, 0
    for i in range(start, end + 1):
        if left[il] < right[ir]:
            nums[i] = left[il]
            il += 1
        else:
            nums[i] = right[ir]
            ir += 1

def merge_sort(nums, start, end) -> int:
    if start >= end: return 0

    m = (start + end) // 2
    merge_sort(nums, start, m)
    merge_sort(nums, m + 1, end)

    merge(nums, start, end)

# merge_sort(nums, 0, len(nums) - 1)

```

### å †

```python
# æ’å…¥æ–°å…ƒç´ ä»¥åŠæŸ¥æ‰¾æœ€å°å…ƒç´ å¤æ‚åº¦å‡ä¸ºlogn
import heapq

heap = []
heapq.heappush(heap, 2)
heapq.heappush(heap, 1)

if heap:
    peek = heapq.heappop(heap)  # å¼¹å‡ºæœ€å°çš„å€¼

```

### äºŒåˆ†æŸ¥æ‰¾(éé€’å½’)

```python
def search(nums):
    i, j = 0, len(nums) - 1
    while i <= j and i < len(nums):
        mid = (i + j) // 2
        if nums[mid] > target:
            j = mid - 1
        elif nums[mid] < target:
            i = mid + 1
        else:
            return mid if nums[mid] == target else -1
          
    return -1
```
### æ·±æœï¼šdfså…ˆå¾ªç¯ååˆ¤æ–­

```python
def dfs(n, target, cur):
    for i in range(n, l):  # å…ˆå¾ªç¯
        if target == candidates[i]:  # å¾ªç¯å†…åˆ¤æ–­
            ans.append(cur + [candidates[i]])
            return
        cur.append(candidates[i])
        dfs(i + 1, target - candidates[i], cur)
        cur.remove(candidates[i])

dfs(0, target, [])

```

### æ·±æœï¼šdfså…ˆåˆ¤æ–­åå¾ªç¯

```python
def dfs(n, target, cur):
    nonlocal l
    if target < 0:
        return

    if target == 0:  # å…ˆåˆ¤æ–­
        ans.append(cur.copy())
        return

    for i in range(n + 1, l):  # åå¾ªç¯
        cur.append(candidates[i])
        dfs(i, target - candidates[i], cur)
        cur.remove(candidates[i])

```

### æ·±æœï¼šdfs(å»é™¤é‡å¤âŒ)

```python
# 1 2 2 2  å»é™¤é‡å¤çš„122
nums.sort()
ans = []
l = len(nums)
def dfs(n, temp):
    ans.append(temp.copy())
    nonlocal l
    for i in range(n, l):
        if i == n or nums[i] != nums[i-1]:  # é™¤äº†ç¬¬ä¸€ä¸ªå…ƒç´ å¤–ï¼Œä¸ä½¿ç”¨å’Œä¸Šä¸€ä¸ªé‡å¤çš„å…ƒç´ ã€‚
            temp.append(nums[i])
            dfs(i+1, temp)
            temp.remove(nums[i])

dfs(0, [])
return ans
```

### æ·±æœï¼šdfs(è¿·å®«ã€è·¯å¾„)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
# matrix = grid = board
m = len(matrix)
if not m: return 0
n = len(matrix[0])

visited = [[False for _ in range(n)] for _ in range(m)]
ans = 0

def dfs(i, j, depth=0):   
    nonlocal ans
    if i < 0 or j < 0 or i >= m or j >= n:  # è¾¹ç•Œ
        return 

    if visited[i][j] or matrix[i][j] == 'X':  # ä¸èƒ½èµ°
        return

    visited[i][j] = True
    depth = depth + 1  # åŠ å®Œ1ä¹‹åæ˜¯çœŸæ­£çš„æ·±åº¦
    # ans = max(ans, depth)  # åœ¨è¿™é‡Œæ›´æ–°ans
    
    for di, dj in arounds:
        dfs(i + di,j + dj, depth) 

    visited[i][j] = False
    
dfs(0, 0)
```



### å¹¿æœï¼šbfs(æ‰¾å‡ºæ‰€æœ‰è·¯å¾„)

```python
queue = [beginWord]
visited[beginWord] = True

while queue:
    for q in queue:
        if q == endWord:
            return paths[endWord]  # åˆ°è¾¾ç»ˆç‚¹

    temp = []
    for q in queue:
        for neibour in get_edges(q):  # æ‰€æœ‰ç›¸é‚»çš„è·¯å¾„
            if not visited[neibour]:
                if neibour not in temp:
                    visited[neibour] = True
                    temp.append(neibour)

                # for path in paths[q]:  # è®°å½•å›æº¯ä¿¡æ¯
                #     paths[neibour].append(path + [neibour])

    queue = temp

return []  # æ— æ³•åˆ°è¾¾ç»ˆç‚¹

```

### å¹¿æœï¼šbfs(è…çƒ‚çš„æ©˜å­ğŸŠ)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
grid = matrix
m = len(matrix)
if not m: return []
n = len(matrix[0])

temp = []

def rot(x, y):
    if x < 0 or y < 0 or x >= len(grid) or y >= len(grid[0]):
        return False
    if grid[x][y] != 0:  # æˆåŠŸè…çƒ‚æ–°é²œçš„æ©˜å­ï¼Œè¿”å›True
        grid[x][y] = 0  
        temp.append((x, y))
        return True
    return False

depth = 0
queue = []
for i in range(m):
    for j in range(n):
        if grid[i][j] == 0:  # åˆšå¼€å§‹è…çƒ‚çš„æ©˜å­
            queue.append((i, j))

while queue: 
    temp = []
    for i, j in queue:
        for di, dj in arounds:
            rot(i + di, j + dj)

    depth += 1

    queue = temp

return ans
```

### å¹¿æœï¼šbfs(æ ‘ğŸŒ²å±‚åºéå†)

```python
#def level_traversal(root):
    if not root:
        return   # å¡«å……è¿”å›ç±»å‹
        
    queue = [root]
    ans = []
    while queue:
        temp = []
        # queueå­˜æ”¾çš„æ˜¯å½“å‰å±‚çš„æ‰€æœ‰ç»“ç‚¹
        for q in queue:
            if q.left:
                temp.append(q.left)
            if q.right:
                temp.append(q.right)
        
        queue = temp
    return ans
```

### å¹¿æœï¼šbfs(è¿·å®«ã€æœ€çŸ­è·¯å¾„)

```python
arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # ä¸Šä¸‹å·¦å³
m = len(matrix)
if not m: return 0
n = len(matrix[0])

visited = [[False for _ in range(n)] for _ in range(m)]

queue = [(0, 0)]  # èµ·å§‹ä½ç½®
visited[0][0] = True

count = 0
while queue:
    for i, j in queue:
        if i == m - 1 and j == n - 1:
            return count  # ç»“æŸçš„æ¡ä»¶
        
    count += 1

    temp = []
    for i, j in queue:
        for di, dj in arounds:
            x, y = i + di, j + dj
            if x < 0 or y < 0 or x >= m or y >= n:  # è¾¹ç•Œ
                continue
            if not visited[x][y]:
                visited[x][y] = True
                temp.append((x, y))

    queue = temp

```

## å­—ç¬¦ä¸²å¤„ç†

### åŒæŒ‡é’ˆ

```python
# æ•°ç»„æ˜¯nums å­—ç¬¦ä¸²åˆ™æ˜¯s
n = len(nums)
if not n: return 0
ans = float('inf')
wnd = 0  # çª—å£å†…çš„ç»“æœ

left = 0
for right, num in enumerate(nums):
    wnd += num
    if wnd >= s:
        while wnd >= s:
            wnd -= nums[left]
            left += 1
            
        ans = min(ans, right - left + 2)

return ans if ans != float('inf') else 0
```

### KMPçš„nextæ•°ç»„

```python
def get_next(t):
    j, k = 0, -1
    n = len(t)
    next = [-1 for i in range(n+1)]
    while j < n:
        if k == -1 or t[j] == t[k]:
            j += 1
            k += 1
            next[j] = k
        else:
            k = next[k]
    return next
  
# t = "ababab"
# get_next(t) = [-1, 0, 0, 1, 2, 3, 4]
```

### KMPæ¨¡æ¿åŒ¹é…

```python
def kmp(s: str, t: str) -> int:
    next = get_next(t)
    i, j = 0, 0
    while i < len(s) and j < len(t):
        if j == -1 or s[i] == t[j]:
            i += 1
            j += 1
        else:
            j = next[j]
    if j >= len(t):
        return i - len(t)
    else:
        return -1

# kmp('abdeabcd', 'abc')) = 4
# kmp('abde', 'abc') = -1
```


### æœ€é•¿å…¬å…±å‰åç¼€

```python
#  "aaabxeaaab" = 4
class Solution:
    def longestPrefix(self, s: str) -> str:
        j, k = 0, -1
        n = len(s)
        next = [-1 for i in range(n+1)]
        while j < n:
            if k == -1 or s[j] == s[k]:
                j += 1
                k += 1
                next[j] = k
            else:
                k = next[k]

        return s[:next[n]]
```

### æœ€é•¿å›æ–‡å­ä¸²(é©¬æ‹‰è½¦ç®—æ³•)

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        s = '#' + '#'.join(s) + '#' # å­—ç¬¦ä¸²å¤„ç†ï¼Œç”¨ç‰¹æ®Šå­—ç¬¦éš”ç¦»å­—ç¬¦ä¸²ï¼Œæ–¹ä¾¿å¤„ç†å¶æ•°å­ä¸²
        lens = len(s)
        p = [0] * lens            # p[i]è¡¨ç¤ºiä½œä¸­å¿ƒçš„æœ€é•¿å›æ–‡å­ä¸²çš„åŠå¾„ï¼Œåˆå§‹åŒ–p[i]
        mx = 0                    # ä¹‹å‰æœ€é•¿å›æ–‡å­ä¸²çš„å³è¾¹ç•Œ
        id = 0                    # ä¹‹å‰æœ€é•¿å›æ–‡å­ä¸²çš„ä¸­å¿ƒä½ç½®
        for i in range(lens):     # éå†å­—ç¬¦ä¸²
            if mx > i:
                p[i] = min(mx-i, p[int(2*id-i)]) #ç”±ç†è®ºåˆ†æå¾—åˆ°
            else :                # mx <= i
                p[i] = 1
            while i-p[i] >= 0 and i+p[i] < lens and s[i-p[i]] == s[i+p[i]]:  # æ»¡è¶³å›æ–‡æ¡ä»¶çš„æƒ…å†µä¸‹
                p[i] += 1  # ä¸¤è¾¹æ‰©å±•
            if(i+p[i]) > mx:  # æ–°å­ä¸²å³è¾¹ç•Œè¶…è¿‡äº†ä¹‹å‰æœ€é•¿å­ä¸²å³è¾¹ç•Œ
                mx, id = i+p[i], i # ç§»åŠ¨ä¹‹å‰æœ€é•¿å›æ–‡å­ä¸²çš„ä¸­å¿ƒä½ç½®å’Œè¾¹ç•Œï¼Œç»§ç»­å‘å³åŒ¹é…
        i_res = p.index(max(p)) # è·å–æœ€ç»ˆæœ€é•¿å­ä¸²ä¸­å¿ƒä½ç½®
        s_res = s[i_res-(p[i_res]-1):i_res+p[i_res]] #è·å–æœ€ç»ˆæœ€é•¿å­ä¸²ï¼Œå¸¦"#"
        return s_res.replace('#', '')  # é•¿åº¦ä¸ºï¼šmax(p)-1
```

### å‰ç¼€æ ‘(Trieæ ‘)

```python
# words = ['abcd', 'acd', 'ace', 'bc']
trie = {}  # æ„é€ å­—å…¸æ ‘
for i, word in enumerate(words):
    node = trie
    for char in word:
        node = node.setdefault(char, {})
    node['#'] = i
            
# æœç´¢å­—å…¸æ ‘
tmp = trie
for char in s:
    tmp = tmp[char]
    if "#" in tmp:
        return True  # æ‰¾åˆ°äº†
```

## æ»‘åŠ¨çª—å£

### å›ºå®šé•¿åº¦çš„æ»‘åŠ¨çª—å£

```python
left = 0
wnd = 0
ans = 0
for right, num in enumerate(nums): 
    wnd += num

    if right - left + 1 == k:  # çª—å£å†…çš„æ•°é‡æ­£å¥½ä¸ºk
        ans = max(ans, wnd)
        wnd -= nums[left]  # å‡æ‰ä¸€ä¸ª
        left += 1

```

## æ•°å­¦


### æ’åˆ—ä¸ç»„åˆ

```python
def factor(num):
    if num < 2:
        return 1
    res = 1
    for i in range(1, num+1):
        res *= i
    return res

def A(m, n):
    return factor(m) // factor(m-n)

def C(m, n):
    return A(m, n) // factor(n)
  
# C(5, 3) = (5Ã—4Ã—3)//(3Ã—2Ã—1) = 10
```

### æœ€å¤§å…¬çº¦æ•°(è¾—è½¬ç›¸é™¤æ³•)

```python
def gcd(a, b):
    if a < b:
        a, b = b, a  # ç¡®ä¿å¤§çš„åœ¨å‰é¢
    while b != 0:
        a, b = b, a % b
    return a
```
### åˆ—å‡ºæ‰€æœ‰ç´ è´¨(åŸƒæ‹‰æ‰˜æ–¯ç‰¹å°¼ç­›æ³•)

```python
# è®¡ç®—å°äº1000000çš„æ‰€æœ‰è´¨æ•° åŸƒå¼ç­›
Z = []
P = [True for _ in range(1000)]  # sqrt(1000000) = 1000
for i in range(2, 1000):
    if P[i]:
        Z.append(i)
        for j in range(i * 2, 1000, i):
            P[j] = False
# Z[:100]  å‰100ä¸ªç´ æ•°
```

### å¿«é€Ÿåˆ†è§£è´¨å› æ•°

```python
# åˆ†è§£è´¨å› æ•°
@lru_cache(None)
def Factor(n):
    Res = []
    for p in Z:  #  Z æ˜¯ä¸Šé¢çš„æ‰€æœ‰ç´ æ•°
        if not n % p:
            while not n % p:
                n //= p
            Res.append(p)
    if n != 1:
        Res.append(n)
    return Res
  
# Factor(30) = [2, 3, 5]
```

## å›¾è®ºå’Œæ ‘ğŸŒ²


### æœ‰åºæ•°ç»„æ„å»ºå¹³è¡¡äºŒå‰æ ‘

```python
def build(self, nums, i, j):
    mid = (i+j)//2
    root = TreeNode(nums[mid])
    if(i==j):
        return root
    if i <= mid-1:
        root.left = self.build(nums,i,mid-1)
    if mid+1 <= j:
        root.right = self.build(nums, mid+1, j)

    return root
  
```

### dijskra(å•æºæœ€çŸ­è·¯å¾„)

```python
# å›¾ä¸­ä¸èƒ½å«æœ‰è´Ÿç¯
v = [0] + [float('inf')] * N  # ç»“ç‚¹ä¸‹æ ‡ä»1å¼€å§‹
v[K], q = 0, {K}  # Kæ˜¯èµ·å§‹node
while q:
    t = set()
    for i in q:
        for j in d[i]:
            if v[i] + d[i][j] < v[j]:
                v[j] = v[i] + d[i][j]
                t.add(j)
    q = t
ans = max(v)  # væ˜¯æœ€ç»ˆç»“æœ
```

### æ¬§æ‹‰è·¯å¾„(ä¸€ç¬”ç”»é—®é¢˜)

```python
# Hierholzer ç®—æ³•
stack = ['JFK']  # åˆå§‹ä½ç½®
ans = []
while stack:
    curr = stack[-1]  # peek
    if edges[curr]:  # edges = {'JFK': ['SFO', 'ATL']}
        next = min(edges[curr])
        edges[curr].remove(next)
        stack.append(next)
    else:
        ans.append(curr)
        stack.pop()

return ans[::-1]
```

## é“¾è¡¨

### åˆå¹¶ä¸¤ä¸ªæœ‰åºé“¾è¡¨(é€’å½’)

```python
def merge(self, l1: ListNode, l2: ListNode) -> ListNode:
    if not l1: return l2
    if not l2: return l1
    if l1.val <= l2.val:
        l1.next = self.merge(l1.next, l2)
        return l1
    else:
        l2.next = self.merge(l2.next, l1)
        return l2
```

## è®¡ç®—å‡ ä½•

### äºŒç»´å‡ ä½•

```python
# ç‚¹æ˜¯å¦åœ¨åœ†å†…
def pt_in_circle(x, y, x_c, y_c, r) -> bool: # pt(x, y)  circle(x_c, y_c, r)
    p = complex(x, y)
    c = complex(x_c, y_c)
    if abs(p - c) < r:
        return True
    else:
        return False

# ç‚¹æ˜¯å¦åœ¨çŸ©å½¢å†…
def pt_in_rect(x, y, x1, y1, x2, y2) -> bool:  # pt(x, y)  rect(x1, y1, x2, y2)  x1 < x2, y1 < y2
    if not (x1 <= x <= x2 or x1 >= x >= x2):
        return False
    if not (y1 <= y <= y2 or y1 >= y >= y2):
        return False
    return True

# åœ†æ˜¯å¦å’ŒçŸ©å½¢é‡å 
def circle_inter_rect(x1, y1, x2, y2, x_c, y_c, r) -> bool:  # rect(x1, y1, x2, y2)  circle(x_c, y_c, r)
    # çŸ©å½¢å››ä¸ªé¡¶ç‚¹åœ¨åœ†å†…
    a = pt_in_circle(x_c, y_c, x1, y1, r)
    b = pt_in_circle(x_c, y_c, x2, y1, r)
    c = pt_in_circle(x_c, y_c, x1, y2, r)
    d = pt_in_circle(x_c, y_c, x2, y2, r)

    # åœ†å’ŒçŸ©å½¢åœ¨çŸ©å½¢çš„è¾¹ä¸Šç›¸äº¤
    e = pt_in_rect(x_c, y_c, x1, y1 + r, x2, y1 - r)
    f = pt_in_rect(x_c, y_c, x1, y2 + r, x2, y2 - r)
    g = pt_in_rect(x_c, y_c, x1 - r, y1, x1 + r, y2)
    h = pt_in_rect(x_c, y_c, x2 - r, y1, x2 + r, y2)

    i = pt_in_rect(x_c, y_c, x1, y1, x2, y2)  # åœ†å¿ƒåœ¨çŸ©å½¢å†…

    return a or b or c or d or e or f or g or h or i

def rect_overlap(rec1, rec2) -> bool:  # çŸ©å½¢å’ŒçŸ©å½¢æ˜¯å¦é‡å  rec1(x1, y1, x2, y2)
    if rec2[1] > rec1[3] or rec1[1] > rec2[3]:  # 
        return False

    if rec1[0] > rec2[2] or rec1[2] < rec2[0]:
        return False
```

## å…¶ä»–

### ç³»ç»Ÿé…ç½®å’Œå®

```python
sys.setrecursionlimit(1000000000)

from functools import reduce
from heapq import heappush as hpush, heappop as hpop, heapify as hpify
from bisect import bisect_right as br, bisect_left as bl, insort_right as ir, insort_left as il

arounds = [(-1, 0), (1, 0), (0, -1), (0, 1)]
V = lambda n, default=0: [default for _ in range(n)]
V2 = lambda m, n, default=0: [[default for _ in range(n)] for _ in range(m)]
V3 = lambda l, m, n, default=0: [V2(m, n, default) for _ in range(l)]
V4 = lambda k, l, m, n, default=0: [V3(l, m, n, default) for _ in range(k)]

product = lambda a: reduce(lambda x, y: x * y, a)  # æ•°ç»„çš„ç´¯ä¹˜

lst = lambda b, a=0: list(range(a, b))
make_idx = lambda a: [[num, i] for i, num in enumerate(a)]

push = lambda a, num: list.append(a, num)
lpush = lambda a, num: list.insert(a, 0, num)
pop = lambda a: list.pop(a)
cp = lambda a: list.copy(a)

add = lambda s, num: set.add(s, num)
rm = lambda s, num: set.remove(s, num)

rsort = lambda a: sorted(a, reverse=True)
def bin(num, bits=None):
    res = __builtins__.bin(num)[2:]
    return res if bits is None else '0' * (bits - len(res)) + res

p = print
```

### è®¡æ—¶å™¨

```python
def timer():
    def decorator(fn):
        def measure_time(*args, **kwargs):
            start = time.time()
            result = fn(*args, **kwargs)
            print('Elapsed time: %.6f' % (time.time() - start))
            return result
        return measure_time
    return decorator
  
@timer()
def func():
    a = []
    for i in range(10000000):
        push(a, i)

func()
```

